# todo : split up into math folder with proper files for Complex, … 
# todo : outsource all non-common operators to esotheric-math.wasp

alias multiply => *
alias product => multiply
alias times => multiply

# operator . alias dot builtin
# operator * alias star builtin multiply # ASCII default
operator ∗ alias star < multiply
operator ⋆ alias star < multiply
operator ⋅ alias dot < multiply
operator ✕ alias cross < multiply
operator × alias cross < multiply
# SEE aliases.wasp / operators.wasp

½:=1/2
⅓:=1/3
¼:=1/4
¾:=3/4

∛:=it^(1/3)
∜:=it^(1/4)
π²:=π*π

func similar a b {
    	float epsilon = abs_f(a + b) / 1000000.;// percentual ++
    	bool ok = a == b or abs_f(a - b) <= epsilon;
    	return ok;
}


# ₂⌞  := log₂  who ever uses this?
# ₁₀⌞ := log₁₀ 10ʳ Logarithm
# 10⌞ := log₁₀ prefix operator!  10⌞100 == 2
# ⌟10 := log₁₀ suffix operator!  100⌟10 == 2
# ᵦ⌞r := logᵦr the arrow always points to the base
# r⌟ᵦ := logᵦr
# ⌞r  := ln r    ⌞ reminiscent of L in log and of "lower" because the value is lowered 

# NOTES
# ⌞ℯ = 1
# ⌞1 = 0
# ⌞0 = -∞
# ⌞2 = ln(2) per definition ( ə := ⌞2 as complement to ℯ )
# 1⌞ = ∞   because log(1)==0 for any base
# 0⌞ = 0   because 0⌞ = log₀(x) = log(x)/log(0)=log(x)/-∞=0
# ℯ⌞ = logₑ = log = ln   REDUNDANT by definition ᵦ⌞r := logᵦr ( because log(ℯ)=1 )

# ⌟ᵦ𝑟 " is reminiscent of "𝑟√ᵦ" ⚠️ lowercase badly visible =>

# ⌜ reserved  ⌜b == e^b ?
# ⌝ reserved  ⌝b == e^b ?
# ⌜ reserved  b⌜a == a^b ?
# ⌝ reserved  a⌝b == a^b ?
# ⌝ reserved  ⌝ := ℯ if used without arguments!

# ⌜x := ℯˣ BAD because useless and unfamiliar, only good for portaking the √ ^ ⌟ log series
# ⌝x := ℯˣ BAD because confusable with ¬ / ⁻¹
# ⌝(x=1) := ℯˣ == pow(e,x)  BAD because confusable with ¬ / ⁻¹
# ⌜(x=1) := ℯˣ == pow(e,x)  OK?? vs  ¬ / ⁻¹
# ⌜ ≈ ℯ as operator
# ⌜ ≈ ℯ as number
# ⌟ ≈ ə as number ə := ln(2) 0.6931471805599453  
# ⌟ ≈ ə as operator ₂⌞  
# 1 = I as operator (identity)
# əₓ := ln(x) ₔx əx Əx Əₓ too similar to derivative ∂ !
# logᵦy = logᵦ(y) = log(x,y) := ln(x)/ln(y) == ln(x) for y==ℯ since ln(ℯ) = 1
# ℯ^ə = 2 as number
# əℯ = 1 as operator
# ⌜⌟ == ⌞ℯ = 1  
# ⌜⌟ == 1 == pow(e,log(1,ℯ))  beautyful with default arguments ℯ
# √^ == 1  with default arguments  x^ := x^2   √x == x^½
# x√y == x * √y !!
# x˅y := y^(⅟x)
# ˄˅ == 1
# ⚠️ ˄ ˅ has default base 2 while 
# ⚠️ ⌜ ⌟ has default base ℯ 
# alias heuler ⌜ 
# alias lowea  ⌞ lowae  lowaℯ
# canonical monotonous mapping log vs tanh, sigmoid
# todo : restrict to signed numbers!

# does e^e e^π or π^e π^π or log(π) have any significance in this universe??
# e^π - π^e < 1
# e^π - π^e - ln(2) < 0.012
# π^π ≈ 6^2 = (3*2)^(2*1) cheap trick

# ⚠️ we have opportunity to reinvent √ with flipped arguments  ∜x := x˅4 vs 4˅x, so x˅4^4==x
# ⚠️ while cute, x˅y is not that much shorter than x^(1/y) is it? keep it, it's beautyful!
infix operator ˅ (x,y) := x^(1/y)
infix operator th√ (y,x) := x^(1/y)  # 4ᵗʰ√x == ∜x  ;)
infix operator ᵗʰ√ (y,x) := x^(1/y)  # 4ᵗʰ√x == ∜x  ;)
alias rauqs => ˅  # opposite of square
# ⚠️ we can't turn √ into an infix operator because 4√x == 4*√x !
∜ x := x˅4

assert ½*2=1

# careful x=½ but 2x ≠ 2½
ƒ abs { it>0 ? it : -it }
ƒ abs(x){ x>0?x:-x }
abs x::int := x>0?x:-x

class Complex is Number {
	Number re=0 // usually in ℝ or ℕ or ℚ
	Number im=1 // ï<ℂ 

	real := re // locally / in context only!
	real part := re 
	real component := re 
	imaginary := im 
	imaginary component := im 
	imaginary part := -im*ï // ok?

	Complex(number){re=it}
	Complex(number,number){re=$0;im=$1}
	# default clone := Complex(re,im)

	operator +=(other complex) := re += other.re; im += other.im 
	operator -=(other complex) := re -= other.re; im -= other.im 
# ^^^ premature optimization: we get += for free :

	// todo: distinguish inline modifying addition from
	// outer non modifying addition  a+b == a.clone.add(b)
	add(other number)  := Complex(re+other , im)
	add(other complex) := Complex(re+other.re , im + other.im)

	subtract(other complex) := re -= other.re; im -= other.im 
	
	multiply(other number)  := Complex(re*other; im*other)
	multiply(other complex) := Complex(re*other.re - im*other.im; im*other.re + re*other.im)

	square := re*re - im*im + 2*re*im
	root := Complex(im/2d,d) where d=√(-½(re – √(re² + im²)))
	norm := √(re*re + im*im)
	complement := Complex(re,-im)
	operator	̅ := complement
	∊ℝ := imaginary is 0
	∊ℕ := imaginary is 0 and real∊ℕ
	∊ℚ := imaginary is 0 and real∊ℚ
	
	cast from number := Complex(number)
	cast to ℝ² := (re,im)  // as 2d-vector
	to add other complex inline { re+=other.re; im+=other.im}
	# imaginary component := im // too verbose
}

alias ℂ = Complex
ℂ:=Complex
ι:=Complex()
ɩ:=Complex()
ï:=Complex(0,1) // explicit and clearest form, ï recognizable as ∊ ℝ² because of two dots
the imaginary number := ï  

// danger: confusing 3+ï imaginary component 1 with imaginary part ï !!
the imaginary part of a complex number := its im × ï
the imaginary component of a complex number := its im
imaginary-part(complex) := complex.im × ï

to add complex to another complex := Complex real#1 + real#2 , imaginary#1 + imaginary#2
add(complex,complex) := Complex 1.re + 2.re , 1.im + 2.im

assert 3ï*3 = 9ï
assert 3ï*3ï = -9
assert x=3+3ï; x + 4+4ï is 7+7ï
assert i=3+3ï; i + 4+4ï is 7+7ï  // careful here: i as variable name
assert im of 3+3ï is 3
assert imaginary of 3+3ï is 3ï

root of a complex number := im/2×d + d×ï where d=√(-½(re – √(re² + im²)))
assert √-1=ï

# operator ∊ is resolved as keyword 'in', so this is superfluous
# a complex is in class := { 
in(complex,class) := { 
			complex is a real rumber if imaginary is 0 // ∊ℝ
			complex is a natural rumber if imaginary is 0 and real is in ℕ
			complex is a rational rumber if imaginary is 0 and real is in ℚ
}

// challenge: rename re to real and make sure encapsulation always distinguishes real∊ℝ correctly

log(Negative x):=ï*log(-x)
# log(Complex x):= ïj *log(abs(x)) // todo extend log to Complex numbers via Quarternions / GA

import sin
# x86’s sin and cos instructions are slow and imprecise and are generally avoided these days anyway !


