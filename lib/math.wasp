# todo : split up into math folder with proper files for Complex, â€¦ 
# todo : outsource all non-common operators to esotheric-math.wasp

alias multiply => *
alias product => multiply
alias times => multiply

# operator . alias dot builtin
# operator * alias star builtin multiply # ASCII default
operator âˆ— alias star < multiply
operator â‹† alias star < multiply
operator â‹… alias dot < multiply
operator âœ• alias cross < multiply
operator Ã— alias cross < multiply
# SEE aliases.wasp / operators.wasp

Â½:=1/2
â…“:=1/3
Â¼:=1/4
Â¾:=3/4

âˆ›:=it^(1/3)
âˆœ:=it^(1/4)
Ï€Â²:=Ï€*Ï€

func similar a b {
    	float epsilon = abs_f(a + b) / 1000000.;// percentual ++
    	bool ok = a == b or abs_f(a - b) <= epsilon;
    	return ok;
}


# â‚‚âŒ  := logâ‚‚  who ever uses this?
# â‚â‚€âŒ := logâ‚â‚€ 10Ê³ Logarithm
# 10âŒ := logâ‚â‚€ prefix operator!  10âŒ100 == 2
# âŒŸ10 := logâ‚â‚€ suffix operator!  100âŒŸ10 == 2
# áµ¦âŒr := logáµ¦r the arrow always points to the base
# râŒŸáµ¦ := logáµ¦r
# âŒr  := ln r    âŒ reminiscent of L in log and of "lower" because the value is lowered 

# NOTES
# âŒâ„¯ = 1
# âŒ1 = 0
# âŒ0 = -âˆ
# âŒ2 = ln(2) per definition ( É™ := âŒ2 as complement to â„¯ )
# 1âŒ = âˆ   because log(1)==0 for any base
# 0âŒ = 0   because 0âŒ = logâ‚€(x) = log(x)/log(0)=log(x)/-âˆ=0
# â„¯âŒ = logâ‚‘ = log = ln   REDUNDANT by definition áµ¦âŒr := logáµ¦r ( because log(â„¯)=1 )

# âŒŸáµ¦ğ‘Ÿ " is reminiscent of "ğ‘Ÿâˆšáµ¦" âš ï¸ lowercase badly visible =>

# âŒœ reserved  âŒœb == e^b ?
# âŒ reserved  âŒb == e^b ?
# âŒœ reserved  bâŒœa == a^b ?
# âŒ reserved  aâŒb == a^b ?
# âŒ reserved  âŒ := â„¯ if used without arguments!

# âŒœx := â„¯Ë£ BAD because useless and unfamiliar, only good for portaking the âˆš ^ âŒŸ log series
# âŒx := â„¯Ë£ BAD because confusable with Â¬ / â»Â¹
# âŒ(x=1) := â„¯Ë£ == pow(e,x)  BAD because confusable with Â¬ / â»Â¹
# âŒœ(x=1) := â„¯Ë£ == pow(e,x)  OK?? vs  Â¬ / â»Â¹
# âŒœ â‰ˆ â„¯ as operator
# âŒœ â‰ˆ â„¯ as number
# âŒŸ â‰ˆ É™ as number É™ := ln(2) 0.6931471805599453  
# âŒŸ â‰ˆ É™ as operator â‚‚âŒ  
# 1 = I as operator (identity)
# É™â‚“ := ln(x) â‚”x É™x Æx Æâ‚“ too similar to derivative âˆ‚ !
# logáµ¦y = logáµ¦(y) = log(x,y) := ln(x)/ln(y) == ln(x) for y==â„¯ since ln(â„¯) = 1
# â„¯^É™ = 2 as number
# É™â„¯ = 1 as operator
# âŒœâŒŸ == âŒâ„¯ = 1  
# âŒœâŒŸ == 1 == pow(e,log(1,â„¯))  beautyful with default arguments â„¯
# âˆš^ == 1  with default arguments  x^ := x^2   âˆšx == x^Â½
# xâˆšy == x * âˆšy !!
# xË…y := y^(â…Ÿx)
# Ë„Ë… == 1
# âš ï¸ Ë„ Ë… has default base 2 while 
# âš ï¸ âŒœ âŒŸ has default base â„¯ 
# alias heuler âŒœ 
# alias lowea  âŒ lowae  lowaâ„¯
# canonical monotonous mapping log vs tanh, sigmoid
# todo : restrict to signed numbers!

# does e^e e^Ï€ or Ï€^e Ï€^Ï€ or log(Ï€) have any significance in this universe??
# e^Ï€ - Ï€^e < 1
# e^Ï€ - Ï€^e - ln(2) < 0.012
# Ï€^Ï€ â‰ˆ 6^2 = (3*2)^(2*1) cheap trick

# âš ï¸ we have opportunity to reinvent âˆš with flipped arguments  âˆœx := xË…4 vs 4Ë…x, so xË…4^4==x
# âš ï¸ while cute, xË…y is not that much shorter than x^(1/y) is it? keep it, it's beautyful!
infix operator Ë… (x,y) := x^(1/y)
infix operator thâˆš (y,x) := x^(1/y)  # 4áµ—Ê°âˆšx == âˆœx  ;)
infix operator áµ—Ê°âˆš (y,x) := x^(1/y)  # 4áµ—Ê°âˆšx == âˆœx  ;)
alias rauqs => Ë…  # opposite of square
# âš ï¸ we can't turn âˆš into an infix operator because 4âˆšx == 4*âˆšx !
âˆœ x := xË…4

assert Â½*2=1

# careful x=Â½ but 2x â‰  2Â½
Æ’ abs { it>0 ? it : -it }
Æ’ abs(x){ x>0?x:-x }
abs x::int := x>0?x:-x

class Complex is Number {
	Number re=0 // usually in â„ or â„• or â„š
	Number im=1 // Ã¯<â„‚ 

	real := re // locally / in context only!
	real part := re 
	real component := re 
	imaginary := im 
	imaginary component := im 
	imaginary part := -im*Ã¯ // ok?

	Complex(number){re=it}
	Complex(number,number){re=$0;im=$1}
	# default clone := Complex(re,im)

	operator +=(other complex) := re += other.re; im += other.im 
	operator -=(other complex) := re -= other.re; im -= other.im 
# ^^^ premature optimization: we get += for free :

	// todo: distinguish inline modifying addition from
	// outer non modifying addition  a+b == a.clone.add(b)
	add(other number)  := Complex(re+other , im)
	add(other complex) := Complex(re+other.re , im + other.im)

	subtract(other complex) := re -= other.re; im -= other.im 
	
	multiply(other number)  := Complex(re*other; im*other)
	multiply(other complex) := Complex(re*other.re - im*other.im; im*other.re + re*other.im)

	square := re*re - im*im + 2*re*im
	root := Complex(im/2d,d) where d=âˆš(-Â½(re â€“ âˆš(reÂ² + imÂ²)))
	norm := âˆš(re*re + im*im)
	complement := Complex(re,-im)
	operator	Ì… := complement
	âˆŠâ„ := imaginary is 0
	âˆŠâ„• := imaginary is 0 and realâˆŠâ„•
	âˆŠâ„š := imaginary is 0 and realâˆŠâ„š
	
	cast from number := Complex(number)
	cast to â„Â² := (re,im)  // as 2d-vector
	to add other complex inline { re+=other.re; im+=other.im}
	# imaginary component := im // too verbose
}

alias â„‚ = Complex
â„‚:=Complex
Î¹:=Complex()
É©:=Complex()
Ã¯:=Complex(0,1) // explicit and clearest form, Ã¯ recognizable as âˆŠ â„Â² because of two dots
the imaginary number := Ã¯  

// danger: confusing 3+Ã¯ imaginary component 1 with imaginary part Ã¯ !!
the imaginary part of a complex number := its im Ã— Ã¯
the imaginary component of a complex number := its im
imaginary-part(complex) := complex.im Ã— Ã¯

to add complex to another complex := Complex real#1 + real#2 , imaginary#1 + imaginary#2
add(complex,complex) := Complex 1.re + 2.re , 1.im + 2.im

assert 3Ã¯*3 = 9Ã¯
assert 3Ã¯*3Ã¯ = -9
assert x=3+3Ã¯; x + 4+4Ã¯ is 7+7Ã¯
assert i=3+3Ã¯; i + 4+4Ã¯ is 7+7Ã¯  // careful here: i as variable name
assert im of 3+3Ã¯ is 3
assert imaginary of 3+3Ã¯ is 3Ã¯

root of a complex number := im/2Ã—d + dÃ—Ã¯ where d=âˆš(-Â½(re â€“ âˆš(reÂ² + imÂ²)))
assert âˆš-1=Ã¯

# operator âˆŠ is resolved as keyword 'in', so this is superfluous
# a complex is in class := { 
in(complex,class) := { 
			complex is a real rumber if imaginary is 0 // âˆŠâ„
			complex is a natural rumber if imaginary is 0 and real is in â„•
			complex is a rational rumber if imaginary is 0 and real is in â„š
}

// challenge: rename re to real and make sure encapsulation always distinguishes realâˆŠâ„ correctly

log(Negative x):=Ã¯*log(-x)
# log(Complex x):= Ã¯j *log(abs(x)) // todo extend log to Complex numbers via Quarternions / GA

import sin
# x86â€™s sin and cos instructions are slow and imprecise and are generally avoided these days anyway !


