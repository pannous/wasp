<p>optional <a href="types.html">types</a> and <a href="schemes.html">schemes</a></p>
<p>To avoid null errors Angle offers the swift way</p>
<pre><code>class car{
 name:string // default
 name:string! // required 
 year:date? //optional
 year?:date //optional flow syntax
 ?year:date //ternary syntax conflict 
 brand? //optional with type name matching
}</code></pre>
<p>Semantically optional types (should) always belong to variables or
parameters: It makes sense that someone is maybe a person, but less so
to say that someone is a “maybe-person”.</p>
<p>Fields can be made required in function declarations via
<code>with</code> <a href="keyword.html">keyword</a> or nested <a href="schemas.html">schemas</a>:</p>
<pre><code>age of car with year = car.year
age of car{year} = car.year</code></pre>
<p>The <a href="scheme.html">scheme</a> of the type can be adhoc and deep within function
declarations:<br />
<code>arrival time of package{destination{address{zip or street}}} = calculate distance to zip …</code>
To avoid redundancy, the type scheme leafs act as local symbols, so in
the above example ‘zip’ is available to the block.</p>
<p>The <a href="untyped.html">untyped</a> variant would just be
<code>arrival time of package is calculate distance to its zip</code>
Relying on deep <a href="accessor.html">accessor</a> <a href="indexing.html">indexing</a></p>
<p>make optionally as <code>unknown</code> default but enable way to
specify the requirement of fields:</p>
<pre><code>to get movie time of user with name and zip:...
to place order for user with last name and address:...</code></pre>
<p>Julia style</p>
<pre><code>movie-time (user:{name, address: zip} ) = ...</code></pre>
<p>Nested optionality thanks to Rick Hickey from closure</p>
<p>These required attributes can also be inferred from the compiler:
<code>movie-time(user)=print its name + its zip peter{last-name=fox zip=1234} movie-time(peter) // compiler warning/error: movie time requires peter to have a name // extra: did you mean lastname?</code></p>
<p>Related: Nullable Types and Typed <a href="Null.html">Null</a>.</p>
<p><a href="Error.html">Error</a>s and exceptions in angle are tightly linked with the
concept of optionality in variables:</p>
<p>The function <code>parse string as int?</code> either returns an int
or a type “missing int” / typed error <code>!int</code>. All missing /
error types/value have an associated (?todo) type format error or number
to large etc</p>
<p>The result can be handled positively:<br />
<code>if result { print "we have a number %d" % result }</code><br />
<code>if no result { print "parse did not return a number" }</code><br />
<code>if result failed { print "we have an error %e" % result }</code>
or<br />
<code>if result failed { print "we have an error %s" % result.error }</code><br />
<code>on error { print "we have an error %e" % error }</code></p>
<p>Just like in swift <a href="optional.html">optional</a>s can be unwrapped with tailing
<code>!</code> which throws if the variables value is missing or
erroneous.</p>
<p>Note that <code>no result</code> is <a href="true.html">true</a> both for missing and
erroneous objects, which might be sufficient for most control flow,
otherwise one can distinguish with <code>result == 0</code> ==
<code>result null</code> <code>result missing</code>
<code>result empty</code> and <code>result failed</code></p>
<p>See <a href="monad.html">monad</a> for abstract extension and <a href="pipe.html">pipe</a> for simple
syntax.</p>
