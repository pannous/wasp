<h1 id="open-questions">❓ open questions?</h1>
<h2 id="todo"><a href="todo.html">todo</a></h2>
<p>merge <a href="todo.html">todo</a> with questions?</p>
<h3 id="matching-by-type-name">matching by type name</h3>
<p>does matching by type name lead to undesired behavior? Ambiguity is
ok unless it is detected early and resolvable.</p>
<h3 id="representations">representations</h3>
<p>a{x:1} == a:{x:1} solved: last one is key ++ a{x}{y} == a({x} {y}) vs
a(x y)</p>
<p>consider</p>
<pre><code>get first character in string
get first &#39;a&#39; in string </code></pre>
<p>both have different signatures and semantics the first returns a
character the second returns a position of a character</p>
<p>is this conceptually fixable?</p>
<h3 id="property-it-or-value">property it or value</h3>
<p>property age with implicit getter (value) and setter:<br />
<code>age:set{value=it}</code> OR <code>age:set{it=value}</code> ?</p>
<p>The preferred style is a free declaration:</p>
<p><code>To set the age of a person: value be it</code> OR<br />
<code>To set the age of a person: it be value</code> OR<br />
<code>To set the age of a person: its value be value</code> <a href="?.html">?</a></p>
<p>the keyword <code>value</code> represents the internal value of the
property the keyword <code>it</code> represents the argument to the
setter of the property</p>
<h3 id="arbitrary-keys-in-pairs">arbitrary keys in <a href="pairs.html">pairs</a></h3>
<p><code>hash={peter:123}</code> # <a href="symbolic.html">symbolic</a> peter
<code>hash[peter]=123</code> # <a href="reference.html">reference</a> peter</p>
<h3 id="repeated-symbol-execution">repeated symbol execution</h3>
<p>In which situations does a symbol get executed multiple times?</p>
<pre><code>square x:=x*x # only once: x is argument
square x=x*x  # only once: x is argument
square:=x*x   # twice (or never if kept symbolically)
square=x*x    # only once: x is context variable, or twice?</code></pre>
<p>Related : ### tainted io arguments <a href="Todo.html">Todo</a> Pure functions
can/cannot<a href="?.html">?</a> be tainted by io arguments</p>
<pre><code>square x:=x*x # pure
square random # pure: random is only invoked once as argument
square random() # same
vs
square <a href="&amp;.html">&amp;</a>random # square the FUNCTION random, not it&#39;s return value
square &amp;random == random()*random()</code></pre>
<h3 id="gap-filling">gap filling</h3>
<p>[<a href="#gap-filling">gap filling</a>] is probably a <a href="bad.html">bad</a> idea
What is the point of providing arguments, when unbound external symbols
are resolved anyways?</p>
<pre><code>f y:= y*y+v
f(y=2,v=3) # 7
y=2,v=3;f() # 7</code></pre>
<h3 id="be-vs-is-assignment"><a href="be.html">be</a> vs <a href="is.html">is</a> <a href="assignment.html">assignment</a></h3>
<p><code>square = x*x</code> # error: unknown symbol x OR treat as
<a href=":=.html">:=</a></p>
<h2 id="binding-of-in-operator"><a href="binding.html">binding</a> of ‘in’ <a href="operator.html">operator</a></h2>
<p><a href="indexing.html">indexing</a> operators ‘#’ ‘in’ and ‘of’` <a
href="precedence">bind</a> tightly, so</p>
<p><code>1 + 1 in {1:2} == 1 + {1:2}['1'] == 1+2</code> TODO: REALLY ?
<code>1 + 1 in {1:3} == (1+1) in {1:3} == false</code> Solution:
compiler error: mixing evalutations needs <a href="grouping.html">grouping</a></p>
<h2 id="early-operator-notation-or-late-expression-evalutation">early
operator notation or late expression evalutation</h2>
<p><code>a{x:1} != a {x:1}</code> but {x:1} becomes child of a<br />
<code>a{x:1} == a:{x:1}</code> ?</p>
<h2 id="fundamental-data-type">fundamental data type</h2>
<p>we found that lisp lacked the builtin map primitive, all map
implementations feel like second class citizens. we found that triple
stores rarely lacks support for n-tuples like “yesterday the green cat
jumped over the black fence”. Even mixing attributes and properties begs
the question: How to coherently combine these concepts, especially when
iterating. let’s say we have Peter={ funny, smart, wife=Jule} when we
iterate over peter, how to make sure that the value of wife is not
overlooked? should we support error prone js iteration? The attributes
funny, smart can act both as keys and values: * Peter[0] == funny *
Peter[funny]=true the first variant seems not natural and thus should
receive a special syntax. <code>for each index in peter</code> the other
one should be default:</p>
<p><code>for each property in peter</code>
<code>for each key in peter</code> <code>for each value in peter</code>
sic!! <code>for each attribute in peter</code>
<code>for each field in peter</code></p>
<p><code>for each property of peter</code>
<code>for each key of peter</code> <code>for each value of peter</code>
sic!! <code>for each attribute of peter</code>
<code>for each field of peter</code></p>
<p>or, consistent with java script: just <code>for x of peter</code></p>
<p>That sounds like a solution to the mixed iteration problem: Using js
<code>for i in xs</code> yields a compiler warning or error: “iteration
over index needs special qualifier, did you mean:<br />
1. for index i of xs 1. for property x in xs == 1. for x of xs</p>
<p>The seemingly harmless variants<br />
1. for key, value in xs 1. for key k in xs</p>
<p>still beg the question if the key of attributes is its index or
itself:<br />
* Peter[funny]=true * Peter[0] == funny<br />
solution: the last case only arises with
<code>for index i,v of xs</code> in which case even the index of
<em>wife</em> is returned as a number (3)</p>
<h2 id="suffix-function-operator-precedence">suffix function operator
precedence</h2>
<p><a href="Todo.html">Todo</a> : do <a href="function.html">function</a>s and their corresponding suffix
<a href="operator.html">operator</a>s have the same precedence? I.e. does<br />
<code>square 1+2 == 1+2 squared</code><br />
<code>square 1+2 == 1 + (2 squared)</code> ?</p>
