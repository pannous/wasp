<p>Signals can be broadcasted from any branch of any <a href="thread.html">thread</a> at any
time using <code>send</code> <code>raise</code> or <code>throw</code>.
They can be received in multiple locations using the <code>catch</code>
and <code>on</code> keywords. Unlike <a href="error.html">error</a>s, which are value types,
exceptions are special <a href="signals.html">signals</a> which can only be received higher up
in the call stack.</p>
<pre><code>fun check the surroundings {
  if man nearby: 
    raise stop the machine!
}

fun main {
 go check the surroundings // asynchronous
 on stop the machine{
  cancel everything
  panic
  exit
}
}</code></pre>
<p>Because errors have their own value mechanism, using signals for
control flow is encouraged.</p>
<p>By default a signals type is its name which need not be quoted.
<code>raise stop the machine</code> =&gt;
<code>catch stop the machine</code> As everything in angle, Signals can
be structured data as well, and metadata can be added effortlessly:</p>
<p><code>raise stop the machine{ time:now reason:"human in danger!"}</code></p>
<p>Signals can also be broadcast outside the application and runtime
context, via the <code>broadcast</code> function and via well configured
repeaters. Signals can also be received from outside the application and
runtime context, via well configured channel listeners. This
functionality is part of the standard library and not of the language
abi (except for standardized serialization) and seemingless integration
with the above <code>on</code> keyword, as well as <code>when</code>
<code>before</code> <code>after</code> <code>during</code>
<code>once</code> and <code>whenever</code>. (todo)</p>
<p>These Signal capturing keywords (<code>after</code>‚Ä¶) can also be
used on variables to create (aspect oriented) implicit listeners:</p>
<pre><code>x=10
once x==5 {print &quot;countdown halfway done&quot;}
while x--&gt;0 : print x</code></pre>
<p>Other than conditionals, listeners can react on access: set, get and
change</p>
<pre><code>x=10
on set x {print &quot;x changed to &quot; value}
while x--&gt;0 üëçüèª  </code></pre>
<p>The signal event can be accessed within listeners with the
<code>signal</code>/<code>event</code> keyword</p>
<p>These Signal capturing keywords can also be used on function names to
create (aspect oriented) implicit listeners:</p>
<pre><code>def test: print &quot;test&quot;
after tested: print &quot;ok&quot;
test()</code></pre>
<p>Todo: shall event listeners be registrable post-hoc? that is should
they semantically be pre inserted before the code by the compiler? The
rational behind this is that events might be over before the listeners
are properly registered</p>
