<p>All functions are automatically broadcasting on lists and <a href="pair.html">pair</a>
values:</p>
<pre><code>square number = number*number
square [1 2 3] == [1 4 9]

square [a:1 b:2 c:3] == [a:1 b:4 c:9]

square.([1 2 3]) // julia style

delete file = run `rm $file.name`
delete all files in ls /   # üßê</code></pre>
<p>Even though the <a href="map.html">map</a> <a href="functor.html">functor</a> is part of angle, in 99%
situations it should be superfluous via all/iteration as seen above.</p>
<p>Broadcasting reduces the amount of cases where <a href="function pointers.html">function pointers</a>
are necessary.</p>
<p>Just use <code>square [1 2 3] == [1 4 9]</code> instead of
<code>map &amp;square [1 2 3] == [1 4 9]</code></p>
<h1 id="folding-multiple-arguments">folding multiple arguments</h1>
<p>An interesting special case might be if functions take more than one
argument: <code>int sum(int a, int b) { return a + b; }</code>
<code>sum [ 1 , 2 , 3 ]</code> MIGHT be treated as sum(1,sum(2,3)) //
depending on the associativity or the operator left or right folding or
it doesn‚Äôt matter</p>
<p>Interesting or <a href="bad.html">bad</a> <a href="idea.html">idea</a> ?</p>
<h1 id="ambivalence"><a href="ambivalence.html">ambivalence</a></h1>
<p>how to apply broadcasting on maps?</p>
<pre><code>square [1:a 2:b 3:c] == ?
square [1:1 2:2 3:3] == ?</code></pre>
<p>Broadcasting applies to functions but not to basic operators:</p>
<pre><code>[1,2,3]+4 == [1,2,3,4]
[1,2,3]&gt;&gt;1 == [2, 3] (maybe)
[1,2,3]++ == [2, 3]</code></pre>
<pre><code>In these cases one does have to use the keywords <a href="map.html">map</a> or <a href="each.html">each</a> or wrap the operator into it a <a href="closure.html">closure</a>:</code></pre>
<p>map [1,2,3] {it+1} each [1,2,3] {it+1} [1,2,3] {++} // dodgy</p>
<p>```</p>
<p>MAYBE we adopt ruby style symbols for function pointers too: map
[1,2,3] :++</p>
