<h3 id="significant-whitespace">[<a
href="#significant-whitespace-1">significant whitespace</a>]</h3>
<p>Not directly an ambiguity but something to be aware of:<br />
⚠️ Angle has a few situations where a white space changes the
semantics</p>
<h3 id="resolution-interactive">resolution: interactive</h3>
<p>Ambiguity should ideally be resolved by the compiler by asking
questions.</p>
<p><code>a {x=1}</code> Did you mean a:{x=1} or [a,{x=1}] ?</p>
<p><code>a&gt;b:c</code> Did you mean <code>a&gt;b : c</code> or
<code>a &gt; b:c</code> ?</p>
<h3 id="significant-whitespace-1">significant whitespace</h3>
<p><a href="significant-whitespace.html">significant-whitespace</a> / semantic resolution</p>
<h3 id="single-element-lists">single element lists</h3>
<p>in general in wasp lists plus element means extending the list:
<code>(x,y)+z=(x,y,z)</code> in general in wasp lists of one element are
identical to the element:<br />
<code>(x)=x</code><br />
however this might lead to conflicts, eg in list extensions:<br />
<code>(x)+y=(x y) ≠ x+y</code><br />
resolvable by the parser?</p>
<p>Different <a href="list.html">list</a> separators have different bindings: While 1,2,3
binds as one expression, 1;2;3 yields the last element as return
value.</p>
<h3 id="grouping-vs-application">grouping vs application</h3>
<p>Consider <code>a b</code> <code>(a) (b)</code> <code>{a} (b)</code>
and <code>{a}(b)</code>.<br />
Are they the same? A group with one element is identical to the element
itself:<br />
Axiom <code>(a) == a</code> Is a block with one element identical to the
element itself?<br />
{a} == a ? Is <code>{a} (b)</code> a list with elements {a} and b or is
it b <a href="evaluation">applied</a> to {a} <code>{a}(b)</code> ?</p>
<h3 id="grouping">grouping</h3>
<p>while the precedence of ‘,’ and ’; is clear:
<code>1,2;3,4 == ((1,2);(3,4)) the precedence of ',' and ' ' less is clear:</code>1
2 3 , 4 5 6<code>and</code>1,2,3 4,5,6` both seam like reasonably
natural groupings.</p>
<p>Problematic is the <a href="ambiguity.html">ambiguity</a> in mixing ‘and’, comma and other
operators</p>
<pre><code>x, y == a, b 
x, (y == a) , b   </code></pre>
<p>The last reading is sometimes the desired one, e.g. in argument
lists</p>
<p>x, y as point == x, (y as point) or x, y as point == (x, y) as point
== point(x,y)</p>
<pre><code>
<a href="Todo.html">Todo</a>! What to do?

For colons the situation is dire as well:
`a b c:d` versus
`to skin a cat: do something` 
<a href="significant-white.html">significant-white</a> space to the rescue!

### burden of calls withoug parens 
`square 3` yields a certain <a href="beauty.html">beauty</a>
However when mixing function calls and operators, things can get ambiguous quickly:
`square 3 * 3 ` can be read as `square (3 * 3)` or `(square 3) * 3`   
`square 3 + square 3` can be read as `square (3 + square 3)` or `(square 3) + square 3`

Operators [bind](precedence) more tightly than functions.
Only the last case where functions are inter-mixed needs special attention:

### resolution: braces via IDE
One way to resolve ambiguities is by making the IDE suggest and insert braces</code></pre>
<p>square 3 + 4 times 3 square(3 + (4 times 3))</p>
<pre><code>
Even though there might not be an ambiguity to the compiler, it can be helpful to insert braces to make it easier for the user to parse the meaning:
`a or b and c   =&gt;   a or (b and c)`

The reasoning behind this is that the developer might not always we be aware of the <a href="function.html">function</a> <a href="operator.html">operator</a> <a href="precedence.html">precedence</a>.

### ambiguity in c
```while (char c = dest[i] and i&gt;0) ```
sets c to 0 or 1 because and binds stronger than assignment!!

## ambiguous referenceIndices
### ambiguous it keyword

In [lambda](closures) expression, the `it` keyword refers to the first (implicit argument), otherwise it refers
to <a href="self.html">self</a> or the last <a href="result.html">result</a>, which can be very ambivalent:
</code></pre>
<p>double=it<em>2 # ok, <a href="evaluation">interpret</a> immediately?
double:it</em>2 # may interpret to anything later double:=it*2 # ok,
implicit argument for function ‘double’</p>
<pre><code>
### functions or functors
```map [1 2 3] square``` could be read as
```map [1 2 3] :square``` symbolic function pointer 
```map ([1 2 3] square) == map [1 4 9]``` 

## variables vs functions 
ambiguous <a href="assignment.html">assignment</a> concepts:</code></pre>
<p>name, age, source = “Crystal, 123, GitHub”.split(“,”) #
deconstruction assignment name age, source := “Crystal, 123,
GitHub”.split(“,”) # function ‘name’ with arguments age, source</p>
<pre><code>The last case is especially problematic with 

# Multi word variable names and typed variables
name age := age+1 The function &#39;name&#39; with parameter age could also be read as name_age or age(type=name)

### block evaluation

Ideally we could reconcile `f={a:1 b:2} f[a] == 1` with the current mechanism `f(a=3) == {a:3 b:2}` or `f(a=3) == b:2`
or `f(a=3)==2`  because the last expression of the block is returned.
<a href="Map.html">Map</a> <a href="match.html">match</a>ing versus <a href="block.html">block</a> <a href="selection.html">selection</a> versus <a href="construction.html">construction</a>.

### is not

`a is not b // ambiguity: a == !b vs a != b`

### Broadcasting

Broadcasting applies to functions but not to basic operators:
</code></pre>
<p>[1,2,3]+4 == [1,2,3,4] [1,2,3]&gt;&gt;1 == [2, 3] [1,2,3]++ == [2,
3]</p>
<h3 id="operators">operators √ ^</h3>
<p>Because √ and ^ lack graphical [<a href="#grouping">grouping</a>] or
closure in text, their usage is ambivalent:</p>
<pre><code>
√1+2 ≠ √(1+2)
2^x+1 ≠ 2^(x+1)
</code></pre>
<p>The default is that they are strongly <a href="binding.html">binding</a> (high precedence),
but a warning shall be emitted!</p>
<h3 id="similar-operators"><a href="similar.html">similar</a> operators</h3>
<p>3 ≈ 3.1
<code>In an early talk Ken was explaining the advantages of tolerant comparison. A member of the audience asked incredulously, “Surely you don’t mean that when A=B and B=C, A may not equal C?” Without skipping a beat, Ken replied, “Any carpenter knows that!” and went on to the next question.</code></p>
