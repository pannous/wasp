<h1 id="symbols">symbols</h1>
<p>In wasp, <a href="data.html">data</a> and <a href="code.html">code</a> have the same <a href="syntax.html">syntax</a>.</p>
<p>The main difference is that in data everything is a symbol and nearly
nothing is <a href="evaluated.html">evaluated</a>.</p>
<h1 id="explicit-symbols">explicit symbols</h1>
<p>As in other languages :symbols can be made explicit with a preceding
colon. <a href="significant-whitespace.html">significant-whitespace</a> differentiates this syntax from
<a href="map.html">map</a> notation a:b !</p>
<p>The colon symbol syntax is useful to uncharge operators without
separating them via comma: <code>a :plus b == a, plus, b</code></p>
<p>There is an interesting intermediary in un<a href="charged.html">charged</a> code, where
symbols can be <a href="dangling.html">dangling</a>:</p>
<h1 id="difference-between-assignment-and-declaration">difference
between [<a href="#assignment">assignment</a>] and <a href="declaration.html">declaration</a> ( = /
:= )</h1>
<h1 id="assignment">assignment</h1>
<p>All words on the left hand side of [<a
href="#assignment">assignment</a>]s are treated as <a href="symbol.html">symbol</a>s:
<code>x y z = y*y+u</code></p>
<ul>
<li>x is a function declaration symbol</li>
<li>y is a bound argument symbol</li>
<li>z is an unused argument symbol (compiler error or warning)</li>
<li>u is an external symbol, evaluated immediately on construction, or
<a href="deferred.html">deferred</a> in the <a href="shell.html">shell</a></li>
</ul>
<p>⚠️ on assignment the compiler immediately emits an error if a symbol
was not defined before</p>
<h1 id="explicit-declaration">explicit declaration</h1>
<p><code>x y z := y*y+u</code></p>
<ul>
<li>u is an unbound external symbol, evaluated on calling x(y=1)</li>
<li>ok if u is available only on invocation, as parameter
<code>x(y=1,u=2)</code></li>
<li>ok if u is available only on invocation, in the context
<code>u=2; x(y=1)</code></li>
<li>=&gt; error if u is still undefined or <code>y*y+u!</code></li>
</ul>
<p>⚠️ the above context consumption of <code>u</code> may be enforced
with <a href="global.html">global</a> keyword if using <a href="strict.html">strict</a> mode.</p>
<p>⚠️ on declaration the compiler emits an error if a symbol is not
defined in invocations <code>x();x!</code></p>
<p>What is the point of providing arguments, when unbound external
symbols are resolved</p>
<pre><code>x y z := y*y+u
x(y=2,u=3) # 7
y=2,u=3;x() # 7</code></pre>
<p>arguments are more robust and allow <a href="pure.html">pure</a> functions. arguments are
more more efficient, since unbound external symbols require function
calls to query the current <a href="context.html">context</a> on <a href="evaluation.html">evaluation</a></p>
<h1 id="when-to-allow-unknown-symbols">⚠️ when to allow unknown
symbols</h1>
<p>The declaration <code>x y z = y*y+u</code> is problematic for two
reasons:</p>
<ol type="1">
<li><code>u</code> neccessarily refers to an external symbol (variable
…), making x stricty un<a href="pure.html">pure</a>.</li>
<li><code>u</code> might not even be declared or inteded to be
declared.</li>
</ol>
<h1 id="example-usages-of-symbols">Example usages of symbols</h1>
<p>internal keywords can have aliases too, similar to c’s
<code>#define</code>, but they need to be quoted as symbol:</p>
<p><code>alias typedef =&gt; :alias</code></p>
