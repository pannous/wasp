<p>The concepts <a href="class.html">class</a> and type are synonymous and represent
prototypic <a href="schema.html">schema</a>tics of data.</p>
<p><a href="data.html">data</a> in <a href="angle.html">angle</a> is a tree of <a href="node.html">node</a>s. A node has a <a href="type.html">type</a>,
which is itself a node.</p>
<h1 id="types">Types</h1>
<p>Types in angle can be added to <a href="variable.html">variable</a>s with these
<a href="syntax.html">syntax</a>es:</p>
<pre><code>i is 7 as integer
i as integer is 7 
integer i=7
i:integer=7</code></pre>
<p>The <code>as</code> keyword eventually adds a cast to the guaranteed
type.</p>
<p>The <code>as</code> keyword also denotes <a href="return.html">return</a> types of
functions, which is no coincidence: philosophically <a href="charged.html">charged</a>
variables are just <a href="closure.html">closure</a>s without parameters.</p>
<h1 id="typed-arrays">typed arrays</h1>
<p><a href="list.html">list</a>s in angle can be typed with these <a href="syntax.html">syntax</a>es:</p>
<pre><code>letters : chars
letters = chars
letters = char[]
letters = [char]</code></pre>
<h2 id="fixed-length-typed-lists">fixed length typed lists</h2>
<pre><code>upcases = 26 * char
friends = 3 * person
letters = char[3]</code></pre>
<h1 id="typed-arguments">typed arguments</h1>
<p><a href="argument.html">argument</a>s have an additional syntax in which the type and the
variable name conincides</p>
<pre><code>fibonacci number = if number&lt;2 : 0 else fibonacci(number - 1) + fibonacci it - 2</code></pre>
<p>Types can have <a href="alias.html">alias</a>es and <a href="cast.html">cast</a> operators to keep the forest
of types clean.</p>
<p>Note how <a href="number.html">number</a> simulataneously acts as <a href="type.html">type</a> and <a href="variable.html">variable</a>
name.<br />
This is called <a href="matching.html">matching</a> by type name.</p>
<p>When scripting or writing small projects, developers may chose to
omit types thanks to <a href="type-inference.html">type-inference</a>. Otherwise adding types is
encouraged, though never obligatory:</p>
<pre><code>fib int i = if i&lt;2 : 0 else fib(i - 1) + fib i - 2</code></pre>
<h1 id="custom-types">Custom types</h1>
<pre><code>type Human = {
  name: string;
  age: number;
}</code></pre>
<h2 id="optional-types-and-optional-values">Optional types and optional
values</h2>
<h3 id="optional-types">Optional types</h3>
<p>Angle is an optionally typed language meaning types are allowed but
not strictly required. Types on variables and parameters are encouraged
and often helpful for the compiler and humans, but mostly optional due
to <a href="type inference.html">type inference</a>. ### optional values Even though sounding similar,
optional types and <a href="optional.html">optional</a> values are different concepts: Optional
values means that the developer can express the fact that a value may be
absent or on the other hand: <a href="required.html">required</a>.</p>
<p>Example:</p>
<pre><code> contact {
    name required,
    phone number,
    email optional
  }</code></pre>
<p>Here the field name must always have a provided value, but the type
of name is not specified, inferred to be Name by <a href="type matching.html">type matching</a>,
which is compatible to <a href="String.html">String</a>, as all node_pointer in angle.</p>
<p>Here phone number on the other hand has a provided type of Number
(through syntax and inference rules) but the field is not marked as
required, making it semi optimal by default.</p>
<p>Here email has inferred type Email but optional values:<br />
It can be <a href="absent.html">absent</a> or <a href="missing.html">missing</a> or <a href="empty.html">empty</a>, which is internally
expressed by different kinds of typed <a href="null.html">null</a>:<br />
A <a href="missing.html">missing</a> person can never be handed to a function which expects
numbers.</p>
<h3 id="type-declarations">type declarations</h3>
<p>Similar to c# 10 namespaces, per file classes can be declared as
declarations to get rid of unnecessary indentation:</p>
<pre><code>namespace test; //applies to the whole file
class Foo; //applies to the whole file
int bar (){ 42 }
...
int boom (){ -1 } // declares test.Foo.boom</code></pre>
<p>IDE support to display the current context is desirable</p>
<p>By the way an <a href="alias.html">alias</a> for class is type, and for namespace is
<a href="context.html">context</a></p>
<h2 id="internal-and-user-types">internal and user types</h2>
<p>Angle and wasp have internal types which should mostly be isolated
from users,<br />
as well as exposed types which should be the ones used by
developers:</p>
<h3 id="user-types">user types</h3>
<ul>
<li><a href="number.html">number</a></li>
<li><a href="string.html">string</a></li>
<li><a href="any.html">any</a> object, implicit default type</li>
<li><a href="list.html">list</a>s and <a href="map.html">map</a>s often don’t need their type exposed:
<code>x=[1 2 3];y={a:1 b:2 c:3}</code></li>
</ul>
<p>Having <a href="list.html">list</a>s and <a href="map.html">map</a>s as universal builtin types with no
explicit type may come as surprise, but this is one of them main
premises if not <a href="inventions.html">inventions</a> of wasp.</p>
<p>How can any, list and map be the default type at the same time?<br />
Any node can have arbitrary children and thus act as a list. Any node
can have arbitrary properties and thus act as a map. Any list can
contain pairs and thus act as a map. In fact map are just lists of pairs
under the hood.</p>
<p>While every node is any node, there are specializations:</p>
<h3 id="internal-types">Internal types</h3>
<p>A node has these different <strong>internal primitive</strong>
types(kinds),<br />
all aligning to 64 bits in the form of <a href="smart pointer.html">smart pointer</a>s:</p>
<ul>
<li><a href="nil.html">nil</a>s : Null types</li>
<li><a href="object.html">object</a>s : {…} <a href="block.html">block</a> <a href="data.html">data</a> with children denoted by {},
closures</li>
<li><a href="group.html">group</a>s : (…) meta params parameter attributes lists denoted by
()</li>
<li><a href="pattern.html">pattern</a>s : […] selectors matches, annotations! [public export
extern] function mul(x,y){x*y}</li>
<li><a href="string.html">string</a>s</li>
<li><a href="long.html">long</a>s : also for storing ints and bools</li>
<li><a href="real.html">real</a>s : for storing floats and doubles</li>
<li><a href="pointer.html">pointer</a>s : internal wasm <a href="pointer.html">pointer</a></li>
</ul>
<p>Adding children to primitive types is allowed yet usually
discouraged. Since mostly primitive are held by <a href="reference.html">reference</a>s (in
<a href="variable.html">variable</a> <a href="pair.html">pair</a>s), this is a non-issue as properties can be added
to references freely:</p>
<pre><code>x=4
x.even=true // meta information</code></pre>
<p>This will internally be represented as (psydocode:)</p>
<pre><code>{node name=&quot;x&quot; value=4 kind=long children=[{even=true}]}</code></pre>
<p><a href="NodeTypes.h.html">NodeTypes.h</a> and <a href="NodeValues.h.html">NodeValues.h</a> To avoid name clashing, all type
names end with s:</p>
<h1 id="internal-types-1">Internal types</h1>
<p>There are three types of type in Angle: wasm types (i32u etc) wasp
types (<a href="kind.html">kind</a> of <a href="node.html">node</a>) number, strings etc primitives angle types
(classes of <a href="node.html">node</a> <a href="object.html">object</a>s) Date, Time, etc</p>
<h1 id="classes">Classes</h1>
<p>When speaking of type in the context of Angle one usually refers to
the last type of type, as they are the only ones that can be user
defined:</p>
<pre><code>class person{name, email?, address{street,city?}}</code></pre>
<h1 id="algebraic-datatypes">Algebraic datatypes</h1>
<p>While classes are product types, enums and unions are classical sum
types. This concept is extended in languages like <a href="rust.html">rust</a>:</p>
<p>type WebData = NoRequest | Loading | Failure HttpError | Success
MyData</p>
<p>Which allows for great safe pattern matching</p>
<p>Advanced algebraic types would be * Finite limits: a generalisation
of finite products (i.e. the ADT product type), where we additionally
require intersection types. * Finite colimits: generalisation of finite
sums (i.e. the ADT union type), where we additionally require quotient
types</p>
<p>Functions are exponential types</p>
<p>(A<sup>B)</sup>C = A^(B*C): (f) =&gt; (b, c) =&gt; f(c)(b) (f) =&gt;
c =&gt; b =&gt; f(b, c)</p>
<p>Obviously not part of the MVP angle implementation</p>
<h1 id="records-and-equality">Records and equality</h1>
<p>By default all <a href="data.html">data</a> and all classes in Angle that dont define
their own <a href="equality.html">equality</a> <a href="method.html">method</a> are records: Records are distinct from
classes in that record types use value-based equality. Two variables of
a record type are equal if the record type definitions are identical,
and if for every field, the values in both records are equal. For data
the equality comparison descends into children with other children, but
value focussed: a:{x=3.0} and b:{x=3} are equal, because the root name
is considered the variable name and the fields x=3.0 and x=3 are
<a href="compatible.html">compatible</a>.</p>
<h1 id="functions-methods-properties">Functions, methods,
properties</h1>
<p>Record types in Angle are the same as other class types, as all
methods live outside classes, just like in <a href="julia.html">julia</a>, via
multi-<a href="dispatch.html">dispatch</a>:</p>
<pre><code>to kill a person{ tell him: &quot;BYE!&quot;}
to kill a dog{ tell it: &quot;WUF!&quot;}</code></pre>
<p>The register for functions including their <a href="properties.html">properties</a> exists
separately in memory.</p>
<h2 id="internal-value-kind">Internal <a href="value.html">value</a> kind</h2>
<p>The internal value <a href="type.html">type</a> known as node “kind” corresponds losely
with the node “type” which is a pointer to another node.<br />
Example pseudocode:</p>
<pre><code>node{
    value.longy=1
    kind=longs,
    type=BoolType
}
node{
    value.longy=1
    kind=longs,
    type=Integer
}</code></pre>
<p>Hereby <a href="enum.html">enum</a>s and other complex data with the same primitive value
can still be differentiated unless the emitted wasm is optimized.</p>
<h3 id="typed-lists-arrays">Typed <a href="list.html">list</a>s / arrays</h3>
<p>Internal representation Typed arrays have Node kind
<code>Type::arrays</code> and any Node type.</p>
<h3 id="todo-in-and-as-operators-for-typing">Todo <code>in</code> and as
operators for typing</h3>
<pre><code>person{
    age in years
    name as string
}</code></pre>
<h3 id="representation">Representation</h3>
<p>In object space types are just references to <a href="Node.html">Node</a> of internal
Type (NodeTypes.h) classe.</p>
