<p>#Angle specification</p>
<p>Many details of the specification are to be found in separate
articles like <a href="data.html">data</a>, <a href="list.html">list</a> …</p>
<h2 id="datacode-format">data=code format</h2>
<pre class="angle"><code>cat{
    length:7cm
    hair-color:{r=1 g=0 b=0}
    form{
        dimensions=(3, length*2)
    }
    kill{print &#39;🕱&#39;}
}</code></pre>
<p>The data format is a superset to (a subset) of
emascript,json,css,wasp,…</p>
<p>While it looks very different to lisp, it is in fact a very
similar</p>
<p><em>Data calculous</em> “lisp with builtin assignment and hashes”</p>
<p>With very few axioms and primitives:</p>
<h2 id="operators">Operators:</h2>
<ul>
<li><code>:</code> pair : turn two node_pointer into a pair,
<code>a:3</code> (hashed+symbolic). almost identical to:</li>
<li><code>=</code> value : turn two node_pointer into a variable pair,
<code>a=3</code></li>
<li><code>,</code> list : turn two node_pointer into a list. Append if
one is a list. ‘cons’ in lisp</li>
<li><code>;</code> list : end expression/statements, list inside a
block. if 1 : 0 ;</li>
<li><code>.</code> <code>#</code> <code>of</code> <code>in</code>
<code>'s</code> selection: garden of house == house.garden == house’s
garden xs.1 xs#1</li>
<li><code>|</code> pipe/then : output of last command as input for next
command. <code>ls ~ | sort</code></li>
<li><code></code> space acts as comma/concatenator in lists (a b c) ==
(a,b,c) == a-&gt;b-&gt;c</li>
<li><code></code> newline, dedent: acts as comma in lists or closing
‘bracket’ if matching block start usual math operators <code>add</code>
<code>plus</code> <code>times</code> <code>power</code> <code>^</code> …
and logical <code>and</code> <code>or</code> <code>xor</code>
<code>not</code></li>
</ul>
<p>Question: substraction|concatenation|range hair-color vs a-b vs
2001-2020</p>
<p>for static content <code>,</code> <code>;</code> <code></code> are
identical {1 2 3} == {1,2,3} == {1;2;3}</p>
<h2 id="brackets-lists-maps-blocks">brackets: lists maps blocks</h2>
<p>for static content [],(),{} are identical</p>
<p><code>[1,2,3]==(1,2,3)=={1,2,3}</code>
<code>[a:3]==(a:3)=={a:3}</code></p>
<p>If attatched to objects, [],(),{} have different semantics:</p>
<p><code>[export]square(a:int){a*a}</code></p>
<h3 id="brackets">brackets</h3>
<ul>
<li>[…] attributes meta modifiers decorators annotations adjectives
adverbs</li>
<li>(…) groups parameters signatures attributes lists head</li>
<li>{…} body blocks maps lambdas closures children node_pointer</li>
<li>«…» other brackets behave like ()/{} until specified</li>
<li>x[…] index patterns selectors matches</li>
</ul>
<p>brackets: content of () is evaluated, {} is deferred
(block/lambda)</p>
<h3 id="optional-order">optional order</h3>
<p>[a]b == b[a] == a b if a is modifier/operator a + b == + a b if
feasible</p>
<h3 id="optional-brackets">optional brackets</h3>
<p>f a b = f(a b) if f is a method/operator/functor</p>
<p>All kinds of brackets are often optional thanks to operator
prescedence <code>a:=1 2 3</code> == <code>a=(1,2,3)</code>
<code>[extern]void()</code> == <code>extern void</code></p>
<p>Each line is treated as a group by default, unless escaped with<br />
so in lisp <code>(add (1 2))</code> is just <code>add 1 2</code> in
angle</p>
<p>Brackets have different semantics depending on their context, this is
NOT reflected in the data structure, only in its evaluation:</p>
<p>[…]object vs object[…] [attributes] are commonly written on the left
side of objects [indices] on the right site.
e.g. <code>[mutable]list xs</code> but <code>xs[1]=7</code></p>
<p>Question: what about xs[mutable]=7?</p>
<h3 id="indexing">Indexing</h3>
<p>the preferred way to index properties in objects to use the ‘of’ /
‘in’ notation <code>show color of cat</code> or dot notation
<code>show cat.color</code> list items are indexed from 0 in ordinary []
notation <code>items[0]</code> list items are accessed from 1 in
selector # notation <code>item#1</code></p>
<h4 id="value-indexing-symbolic-indexing">value indexing | symbolic
indexing</h4>
<p>x=color cat{color:red} cat.color // red cat.x // ø cat#x // red
cat[x] // red cat#color // red unless color is a variable cat[color] //
red unless color is a variable</p>
<p>Question: how is value indexing done in english?
<code>property=color; get this property from cat</code></p>
<!-- cat$x // red later -->
<p>car(list)=list#1 cdr(list)=rest of list=list…</p>
<h3 id="evaluation-time">Evaluation time</h3>
<p>To make sure an object is evaluated, invoke it with <code>!</code> or
<code>()</code> a=7 x={a+1} print x // {a+1} print x! // 8 a=8 print x!
// 9</p>
<p>parameters are evaluated if given in () and deferred if given as {}
print x // 9 print(x) // 9 print{x} // {a+1} print[x] // print has no
property {a+1}</p>
<p>objects are evaluated if given in () and deferred if given as {}
y=(a+1) // 8</p>
<p>NOTE: Everything inside {blocks} is deferred, including (groups)
a=7;x={print(a+1)};a=1;x() // 2 For instant template evaluation inside
{blocks} use <code>$</code> : a=7;x={print($a+1)};a=1;x() // 8</p>
<p>NOTE: Everything inside (groups) is evaluated, including {blocks}
z={x} print(z) // ({a+1}) (8+1) (9) 9</p>
<h3 id="blocks">Blocks</h3>
<p>block is a builtin data type similar to ‘object’ (inspired by
ruby)</p>
<p>Every group […] (…) {…} «…» is a block at first until special
semantics are given.</p>
<p>A block is basically a deferred multiline lambda</p>
<p>f a b = f(a b) if f is a functor example functor: if.signature ==
condition:block then:block [optional]otherwise:block
if(a=b){go!}{stop!}</p>
<p><code>if</code> could be implemented within the language: if(block
condition, block body, block otherwise){ }</p>
<p>Having blocks as first class citizens makes a lot of code cleaner:
square(x){x^2} {it^2}[1 2 3] == [ 1 4 9]</p>
<p>blocks can be applied to objects from left or from right {a*a}(a=7)
== 49</p>
<p>blocks can be applied/evaluated via <code>!</code> a=6;{a*a}! #36</p>
<p>blocks can be applied/evaluated via () ATTENTION (){} has different
semantics to {}() the first is a deferred list [group(),block()]<br />
the second is an applied list [block(),group()] where the group is
provided as context for the block</p>
<p>example: (x){x<em>x} a lambda (anonymous function) {x</em>x}(x=5) #25
evaluated on the spot</p>
<p>This is particularily important because normaly () is just the empty
object ø, but {go}() will EXECUTE the block containing the statement
‘go’; if ‘go’ was declared as function before, it will return the result
of ‘go’</p>
<p>b=7 x={a=b} x.a # b (here:7) y=x! y=={a=7} b=5 x.a # b (here:5)
y=={a=7} # unchanged because b was resolved</p>
<p>blocks can be applied to lists from left or from right {it^2}[1 2
3]</p>
<h3 id="overlap-with-javascript">Overlap with javascript</h3>
<p>While some blocks might look identical to javascript, the underlying
logic is much more unified. Read the rest of this document for
details.</p>
<p><code>a={b:1,c:d()}</code> Has near identical behavior in javascript
and angle: a variable(‘node’/‘object’) with name ‘a’ is created and has
the properties b and c. while b is static, c recieves the dynamic value
of d() at construction.</p>
<h3 id="differences-to-json">Differences to json</h3>
<p>json sucks, angle is more like ecmascript:</p>
<h3 id="differences-to-javascript">Differences to javascript</h3>
<p><code>a={b:1,c:d()}</code> legal angle and javascript legal syntax
only in angle: <code>a:{b=1,c{d()}}</code> <code>hello:world</code> root
maps <code>{1:i i^2:-1}</code> no restriction on map keys
<code>{a:b}</code> values are symbolic until evaluated (see above)!</p>
<p>Attention:</p>
<p>objects can be constructed with a{} a={} a:{} mostly equivalently in
javascript ‘=’ is used for variable setters and ‘:’ is used for
fields</p>
<p>Groups, blocks, lists () Node <em>param == group attributes meta
modifiers decorators annotations {} Node </em>children == block body
content ‘set’:setters!=Set? [<a href="#setter-problem">Setter
Problem</a>] [] Node *list == selector pattern match a[b]=c == a.b=c
a<a href="b.html">b</a>=c (a that b)=c a@b a~b=c (a.filter(b))=c</p>
<p>DANGER a,b=c,d TWO READINGS 1. (a;b=c;d) 2. (a,b)=(c,d) a b:c d ==
a,(b:c),d “short-binding” a b=c d == (a,b)=(c,d) “number- binding”</p>
<p>usually ‘=’ is number-binding, meaning it has higher prescedence than
other operations, so the second reading is default. Within Groups, ‘=’
is shortbinding like ‘:’ a(href=‘link’ hidden) BUT DANGER: group is
default bag CONTRADICTION</p>
<p>Solution? ‘=’ be left-short-binding a b=c d == (a b):c,d NO WAY
Solution: just write a(href:link style=““) Solution: short-binding in
lists, but how do we know?</p>
<p>Diffenence of maps and constructors <code>color:{r=1 g=0 b=0}</code>
creates object called ‘color’ with r,g,b fields
<code>color{r=1 g=0 b=0}</code> constructs instance of color class with
r,g,b parameters These are EQUIVALENT unless there is a constructor,
e.g.  <code>color{construct(r,g,b){this.rgb=r+g*2^8+b*2^16}}</code></p>
<p>This is an example of class name as variable name. In this context
color is both a variable with name ‘color’ and of type Color.</p>
<h2 id="setter-problem">Setter Problem</h2>
<p><code>cats=[cat{color=brown},cat{color=yellow}]</code> ok, two cats
<code>cats={cat{color=brown};cat{color=yellow}}</code> danger, cat
property gets reassigned! really?
<code>cats(){color=green;sleep 1;color=blue}</code> ok, two setters in
sequence</p>
<p>Then these two objects should still behave very similarily.
Especially the constructor arguments should be unmodified and are
automatically accessible: color.r==1 no matter what.</p>
<p>Assignment and object creation foo{bar:3} #object creation foo(bar:3)
#object creation if (implicit) constructor, else function call
foo:{bar:3} #property assignment (nested objects) foo={bar:3} #variable
assignment (of calling context)</p>
<p>foo:=(x y){x+y} # function creation :foo(x y){x+y} # function
creation to foo(x y){x+y} # function creation</p>
