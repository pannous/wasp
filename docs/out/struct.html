<h1 id="struct-alias-record">struct alias record</h1>
<p>A struct is a collection of <a href="primitive.html">primitive</a>s (int, string, …) and other
structs into a data tuple. While struct is a <a href="node.html">node</a> type, when reading
or writing a struct, the <a href="abi.html">abi</a> omits the node header and directly
handles the primitives on stack or in memory.</p>
<h1 id="wit">wit</h1>
<p>Wasp uses [<a href="#wit">wit</a>] as schema, all wit constructs are
valid wasp, as “prefix notation” in [<a href="#wit">wit</a>] files or
with common wasp syntax:</p>
<pre><code>struct point{
  x:int
  y:int
}
point(1,2).y == 2</code></pre>
<h3 id="structs-and-named-tuples"><a href="struct.html">struct</a>s and named tuples</h3>
<p>structs are instances of classes without the <a href="header.html">header</a> in memory. Or
put the other way round: classes are thin meta wrappers around structs.
While the type information for struct instances is only available at
compile time, the <a href="header.html">header</a> of <a href="class.html">class</a> <a href="instances.html">instances</a> is part of the
data in memory.</p>
<h1 id="todo-pass-by-reference-or-multi-value"><a href="Todo.html">Todo</a> pass by
reference or <a href="multi-value.html">multi-value</a>?</h1>
<p>The wasp abi can return structs either as multi-value or as
references to linear memory</p>
<p>The <code>struct</code> keyword in Angle is very similar to c and
swift. The main differences are: Meta information about all structs is
stored in a custom type table, and or carried via return <a href="type.html">type</a>s.
structs can be part of function dispatch, the only limitation being that
they need to be determined at compile time, because unlike class
instances, structs do not know their own type.</p>
<h1 id="struct-pointers-as-type-schemes">struct pointers as type
<a href="scheme.html">scheme</a>s</h1>
<p>multi-value returns allows to carry meta information about results in
the form of smart pointers.</p>
<p>Each class has one corresponding <code>raw type</code> corresponding
to the struct definition of its fields. <a href="?.html">?</a> structs can contain non
primitive values while classes can only contain reference types. That
is, in classes int is really resolved as type Integer (or
<a href="int60.html">int60</a><a href="?.html">?</a>),</p>
<pre><code>class example{
  level:int 
}</code></pre>
<p>whereas in structs, int is really resolved as type int32</p>
<pre><code>struct example{
  level:int #int32
}</code></pre>
<p>This internal distinction however is almost completely invisible to
the developer.</p>
<p>Compare with NamedTuple(x: Int32, y: String) in ruby and <a href="record.html">record</a>
in C#</p>
<h1 id="node_pointer-as-implicit-structs">node_pointer as implicit
structs</h1>
<p>Todo: can angle distinguish between un-<a href="charged.html">charged</a> data and implicit
struct template prototypes?</p>
<pre><code>f:{time:now} # passive declaration syntax
f.time! ≈ now!

f{time:now}  # active construction syntax (or passive if f is not know or passive)
f(time:tomorrow) # active construction depending on existing symbol f
f(tomorrow) == f{time:tomorrow}</code></pre>
<h1
id="unification-of-structs-enums-and-interfaces-prototypes-and-classes">unification
of structs enums and interfaces prototypes and classes</h1>
<p>interfaces are just classes without concrete fields and without
implementations</p>
<p>structs are just classes without header internally, so they should
ONLY be used in extern FFI abi calls, right?</p>
<p>structs are just named tuples?</p>
<p>Alternative one can call and access foreign libraries functions and
data just by (IMPLICITLY) applying the right abi.</p>
<p>Currently <code>record</code> is just an alias for
<code>struct</code></p>
<p>record pair { x: u32, y: u32, }</p>
<p>record person { name: string, age: u32, has-lego-action-figure: bool,
}</p>
<p>A <code>flags</code> statement defines a new <code>record</code>-like
structure where all the fields are booleans.</p>
<p>https://raw.githubusercontent.com/WebAssembly/component-model/main/design/mvp/WIT.md</p>
<h1 id="wit-variant">Wit variant</h1>
<h3 id="item-variant-one-of-a-set-of-types">Item: <code>variant</code>
(one of a set of types)</h3>
<p>A <code>variant</code> statement defines a new type where instances
of the type match exactly one of the variants listed for the type. This
is similar to a “sum” type in algebraic datatypes (or an
<code>enum</code> in Rust if you’re familiar with it). Variants can be
thought of as tagged unions as well.</p>
<p>Each case of a variant can have an optional type associated with it
which is present when values have that particular case’s tag.</p>
<p>All <code>variant</code> type must have at least one case
specified.</p>
<pre class="wit"><code>variant filter {
    all,
    none,
    some(list&lt;string&gt;),
}</code></pre>
<p>An <code>enum</code> statement defines a new type which is
semantically equivalent to a <code>variant</code> where none of the
cases have a payload type.</p>
<p>A <code>union</code> statement defines a new type which is
semantically equivalent to a <code>variant</code> where all of the cases
have a payload type and the case names are numerical.</p>
<h2 id="item-resource">Item: <code>resource</code></h2>
<p>Resources represent a value that has a hidden representation not
known to the outside world.</p>
<p>This means that the resource is operated on through a “handle” (a
pointer of sorts). Resources also have ownership associated with them
and languages will have to manage the lifetime of resources manually
(they’re similar to file descriptors).</p>
<p>Resources can also optionally have functions defined within them
which adds an implicit “self” argument as the first argument to each
function of the same type of the including resource, unless the function
is flagged as <code>static</code>.</p>
<pre class="wit"><code>resource file-descriptor

resource request {
    static new: func() -&gt; request

    body: func() -&gt; future&lt;list&lt;u8&gt;&gt;
    headers: func() -&gt; list&lt;string&gt;
}</code></pre>
<p>Types</p>
<pre class="wit"><code>type number = u32
type fallible-function-result = result&lt;u32, string&gt;
type headers = list&lt;string&gt;</code></pre>
<p>Types in wit, however, cannot be recursive:</p>
<h1 id="auto-marshalling">Auto Marshalling</h1>
<p>Example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> point<span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> stretch_y<span class="op">(</span>point<span class="op">&amp;</span> p<span class="op">){</span>p<span class="op">-&gt;</span>y<span class="op">*=</span><span class="dv">2</span><span class="op">;}</span></span></code></pre></div>
<pre class="wasp"><code>stretch_y {1,2}  # unsave 
stretch_y {1,2}  # file if reflected upon c with canonical abi
stretch_y point{1,2}  # extra file, don&#39;t pass class, but just POINTER to data according to abi</code></pre>
<h1 id="gnu-style">gnu style</h1>
<p>Both old and new gnu style initialization of instances is valid, the
later giving more savety:</p>
<pre><code>ParserOptions{use_tags = true, kebab_case = true}
ParserOptions{.use_tags = true, .kebab_case = true}</code></pre>
<h1 id="struct-extensions">struct extensions</h1>
<p>Expandable structures enforce a scheme, but also allow extra
elements.</p>
<p>Example:</p>
<pre><code>extendible struct Point{ int x, int y}

Point test{y=7, x=8, z=9} // ok extra elements are stored behind ordered fields 

Upon using extendible structs in abis the behaviour for the extra elements needs to be specified.

⚠️ The extra data will be LOST in external receivers of the struct and are only valueable for read-compatibility or for internal meta handling.

⚠️ Angle classes are similar to extendible structs!
However since <a href="Angle.html">Angle</a> <a href="class.html">class</a>es are of type <a href="node.html">node</a>, the extra members will be handled transparently.

That is: while usage of structs in abi calls require strict memory layout, internal (or external) passing of node_pointer is always just a reference / pointer to a wasp node tree.

# aliases
extendible structs are just called `extendible` or `expandable`
extendible struct are also called `open struct`

Currently the keyword `record` is aliased to struct but may receive specific semantics in the future.

# wit interfaces types as implemented in v8 (node v20) :</code></pre>
<p>(module (type ${f64_f64} (struct (field f64) (field f64))) (type
$f64_f64_=&gt;<em>ref|{f64_f64}| (func (param f64 f64) (result (ref
${f64_f64})))) (type $ref|{f64_f64}|</em>=&gt;_f64 (func (param (ref
${f64_f64})) (result f64))) (export “create_point” (func $0)) (export
“length” (func $1)) (func $0 (param $0 f64) (param $1 f64) (result (ref
${f64_f64})) (struct.new ${f64_f64} (local.get $0) (local.get $1) ) )
(func $1 (param $0 (ref ${f64_f64})) (result f64) (f64.add (f64.mul
(struct.get ${f64_f64} 0 (local.get $0) ) (struct.get ${f64_f64} 0
(local.get $0) ) ) (f64.mul (struct.get ${f64_f64} 1 (local.get $0) )
(struct.get ${f64_f64} 1 (local.get $0) ) ) ) ) )</p>
<p>```</p>
