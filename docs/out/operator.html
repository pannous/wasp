<p>Functions group externally square 1 + 2 == square(1 + 2) VS
√4+5=√(4)+5 Operators group tighter than functions</p>
<p>Functions expect their arguments on the right hand side<br />
Suffix operators expect their arguments on the left-hand side
e.g. ²=square <code>x²</code><br />
Infix operators expect their arguments on both side: <code>x+y</code>
<code>x*y</code> …<br />
Prefix operators expect their arguments on the right-hand side
<code>-x, ++x, !x, ½x</code><br />
Circumfix operators are such as (…) {…} “…” are all built in and not
overwritable <a href="todo.html">todo</a><br />
N-ary operators are currently not supported ( x = 5 % 7 <a href="todo.html">todo</a>:
because they can be rewritten x%7==5 ? )</p>
<p>General N-ary operators are currently not supported (
e.g. mathematical equals-with-respect-to x == y % z <a href="todo.html">todo</a>: because
they can be rewritten x%z==y%z ? ) Special hardwired ternary operators:
array#position=value, list[index]=value, data[pattern]=value,
condition?then:else The first cases can be handled via
<a href="reference.html">reference</a>s</p>
<p>UTF symbols and their english aliases are almost completely identical
when parsing and evaluating 1 + 2 == 1 plus 2 == 1 add 2</p>
<p>goals</p>
<p>Operators follow an alias hierarchy, so a &amp; b will try to invoke
<code>et, and, add</code> and may even fallback to
<code>plus combine concat</code>, or let the compiler suggest such
fallbacks if the functions are not implemented on the object.</p>
<p>List of operators and their variants (see aliases.wasp):</p>
<pre><code>* et &amp;
* and &amp;&amp; ⋀ ∧
* or || ⋁ ∨ 
* xor ^| ⊻
* not ! ¬
* add +
* plus +
* minus subtract sub -
* times mul * × ⋅ multiply
* div / ÷
* mod modulo %
* equal equals ≟ == ≡ ﹦ 
* similar circa ~ ⋍ ≈ ~~ approximately
* more bigger &gt;
* less smaller &lt;
* exp / to the power ^
* square_root √ sqrt
* increase ++ 
* increase … by  +=
* reduce --
* reduce … by  -=
* divide … by  /=
* to … / … be :=  
* to-the ^
* be :=
* is := or == or instance
* then pipe |
* of in @
* &#39;s with .
* that / with / which / filter []
* index nr 1st 2nd 3rd 4th nth _th #
* xor ⊻ ^|
* nand ¬&amp;</code></pre>
<h3 id="caution-in-angle-is-power-to-the-xor-is">Caution: ^ in <a href="Angle.html">Angle</a>
is power “to the”, xor is ^| ⊻</h3>
<h3
id="note-bitwise-operators-are-also-allowed-for-truthyness-comparisons">Note:
bitwise operators &amp; | are also allowed for <a href="truthyness.html">truthyness</a>
comparisons</h3>
<p>However the english variants or mathematical signs are usually
prefered.</p>
<p>Keywords that resolve to operators depending on context:</p>
<pre><code>is in of to from sub super</code></pre>
<h1
id="the-operator-is-context-sensitive-usually-it-acts-as-assignment-like-in-conditions-it-acts-as-comparison-like">The
‘=’ operator is context sensitive: usually it acts as assignment like
:=, in conditions it acts as comparison like</h1>
<p>Operators are usually <a href="pure.html">pure</a> meaning that they are side effects
free and do not use global information.</p>
<p>Operators can be self modifying, such as <code>++</code>,
<code>+=</code> and <code>&lt;&lt;</code> as in</p>
<p><code>cout &lt;&lt; "Hello" &lt;&lt; " " &lt;&lt; "world!" &lt;&lt; endl;</code></p>
<h2 id="control-flow-keywords">control flow keywords</h2>
<p>if then else otherwise once when times try catch except while until
unless</p>
<h2 id="infix-operators">Infix operators</h2>
<p>Infix operators in Angle (as in Julia) are simply functions that can
be used with an alternative syntax.</p>
<h2 id="operator-overloading">Operator overloading</h2>
<p>The behavior of operators can be documented or changed by declaring
either the symbol or the name
<code>to add a tree to an image: paint tree on image</code><br />
<code>tree + image := paint tree on image</code></p>
<p>All Operators automatically receive a self modifying variant:
<code>x ⊛= b</code> is always a shorthand for <code>x = x ⊛ b</code> for
all custom operators (⊛ here being a wildcard placeholder).</p>
<p>Introducing a new operator changes the lexical specification of the
language, which changes the lexical analysis. The arity and precedence
of the operator is then part of the phrase syntax of the language, which
changes the phrase-level analysis. For example, adding an operator @
requires lexing and tokenizing this character, and the phrase structure
( syntax tree) depends on the arity and precedence of this operator.</p>
<p>Functions group externally: square 1 + 2 == square(1 + 2) VS
√4+5=√(4)+5 Operators group tighter than functions</p>
<pre><code>prefix operator ⁻ := it*-1
suffix operator ⁰ := 1
suffix operator ³ := it*it*it</code></pre>
<p>Note that suffix operators correspond to (prefix) functions:</p>
<pre><code>x² = square x </code></pre>
<p>Note that suffix operators correspond to (suffix) language concious
functions: x² = x squared</p>
<pre><code>squared is recognized as grammatical form of the &#39;square&#39; function.

This simple pattern holds for all functions:</code></pre>
<p><name> x == x <name>d ```</p>
<p>See k programming language
https://estradajke.github.io/k9-simples/k9/index.html
https://news.ycombinator.com/item?id=28493283</p>
<h1 id="superscript-signs-bind-higher-x²³-x⁵">superscript signs bind
higher! <code>x²⁺³ == x⁵</code></h1>
