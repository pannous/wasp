<h1 id="wasm">wasm</h1>
<p>Since wasm is <a
href="https://caniuse.com/?search=wasm">supported</a> pretty much
universally for some time now we can now ask for the next steps after
the MVP:</p>
<p>https://wasm-feature-detect.surma.technology/</p>
<p>Supported wasm features as of 2021:</p>
<p>https://webassembly.org/roadmap/ !</p>
<p>https://github.com/WebAssembly/proposals</p>
<h1 id="hosts-browsers">HOSTS BROWSERS</h1>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 4%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Node20</th>
<th>Chrome</th>
<th>Safari</th>
<th>WebKit</th>
<th>Firefox</th>
<th>Feature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td><a href="multi-value">multiValue</a></td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>bigInt</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>bulkMemory</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>exceptions</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>extendedConst</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>memory64</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>mutableGlobals</td>
</tr>
<tr class="even">
<td>âœ”ï¸[1]</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>referenceTypes (externref)</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>saturatedFloatToInt</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>streamingCompilation</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>signExtensions</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>SIMD âš ï¸ â‡¨ <a
href="https://github.com/WebAssembly/flexible-vectors/blob/main/proposals/flexible-vectors/FlexibleVectors.md">Flexible
Vectors</a> relaxed-simd</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>tailCall</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸/âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>threads</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>GC: reference-types type struct (Chrome 108, FF 111)</td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>GC: interface types &lt;= webidl â‰  reference-types</td>
</tr>
<tr class="odd">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a href="https://github.com/WebAssembly/proposal-type-imports">type
imports</a> <a
href="https://github.com/WebAssembly/proposal-type-imports/blob/main/proposals/type-imports/Overview.md">Overview</a></td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/function-references">function-references</a></td>
</tr>
<tr class="odd">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration">import/script
type=module</a></td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>https://github.com/tc39/proposal-import-reflection import module Foo
from â€œfoo.wasmâ€;</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>typeReflection ?</td>
</tr>
<tr class="even">
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td><a
href="https://github.com/WebAssembly/multi-memory">multi-memory</a></td>
</tr>
<tr class="odd">
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>jspi (Java Script Promise Integration: async!)</td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/stringref/blob/main/proposals/stringref/Overview.md">stringref</a>
GC?</td>
</tr>
</tbody>
</table>
<h1 id="binaryen">binaryen</h1>
<p><a href="http://github.com/WebAssembly/binaryen.git">binaryen</a>
<code>wasm-as --all</code> is always first to implement proposals: âœ”ï¸
multi-memory âœ”ï¸ GC âœ”ï¸ GC non-null locals âœ”ï¸ strings âœ”ï¸ extended
const</p>
<p><a href="wit.html">wit</a> / wasm world <a
href="https://github.com/WebAssembly/component-model/tree/main/design/mvp">Component
Model</a> MVP <a
href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md">Canonical
ABI</a> <a href="">webidl</a> <a
href="https://github.com/WebAssembly/stringref">strings</a> <a
href="#sharedarraybuffer">SharedArrayBuffer</a> has lately been DISABLED
in all browsers!</p>
<h1 id="tools">TOOLS</h1>
<p>Binaryen | Binaryen | Wabt | Feature<br />
wasm-as | wasm-objdump| wat2wasm | â€”â€”â€”|â€”â€”â€”â€”-|â€”â€”â€”-|â€”â€”â€”- âœ”ï¸ | âœ”ï¸ | <a
href="multi-value">multiValue</a> âœ”ï¸ | âŒ | stringref
https://github.com/WebAssembly/wabt/issues/2144</p>
<h1 id="runtimes">RUNTIMES</h1>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>Wasmer</th>
<th>Wasmtime</th>
<th>Wasm3</th>
<th>Wasmedge</th>
<th>Firefox</th>
<th>Feature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td><a href="multi-value">multiValue</a></td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>bigInt</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>bulkMemory</td>
</tr>
<tr class="even">
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>exceptions</td>
</tr>
<tr class="odd">
<td>âŒ</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td></td>
<td>extendedConst</td>
</tr>
<tr class="even">
<td>?</td>
<td>âŒ</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td></td>
<td>memory64</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>mutableGlobals</td>
</tr>
<tr class="even">
<td>âœ”ï¸[1]</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>âœ”ï¸</td>
<td>referenceTypes (externref)</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>saturatedFloatToInt</td>
</tr>
<tr class="even">
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td>âœ”ï¸</td>
<td></td>
<td>signExtensions</td>
</tr>
<tr class="odd">
<td>âœ”ï¸âš ï¸</td>
<td>âœ”ï¸âš ï¸</td>
<td>âŒ</td>
<td>âš ï¸</td>
<td>âœ”ï¸âš ï¸</td>
<td>SIMD âš ï¸ â‡¨ <a
href="https://github.com/WebAssembly/flexible-vectors/blob/main/proposals/flexible-vectors/FlexibleVectors.md">Flexible
Vectors</a></td>
</tr>
<tr class="even">
<td>âŒ</td>
<td>âœ”ï¸</td>
<td>âŒ</td>
<td>âœ”ï¸</td>
<td></td>
<td>tailCall</td>
</tr>
<tr class="odd">
<td>âœ”ï¸</td>
<td>âœ”ï¸/âŒ</td>
<td>âŒ</td>
<td></td>
<td>âŒ</td>
<td>threads</td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>typeReflection</td>
</tr>
<tr class="odd">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/function-references">funcReferences</a></td>
</tr>
<tr class="even">
<td>âœ”ï¸[1]</td>
<td>âœ”ï¸[2]</td>
<td>?</td>
<td>âœ”ï¸</td>
<td>?</td>
<td>interface types / reference-types component model &lt;= webidl</td>
</tr>
<tr class="odd">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a href="https://github.com/WebAssembly/proposal-type-imports">type
imports</a> <a
href="https://github.com/WebAssembly/proposal-type-imports/blob/main/proposals/type-imports/Overview.md">Overview</a></td>
</tr>
<tr class="even">
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration">import/script
type=module</a></td>
</tr>
<tr class="odd">
<td>?</td>
<td>?</td>
<td>?</td>
<td>âœ”ï¸</td>
<td>?</td>
<td><a
href="https://github.com/WebAssembly/multi-memory">multi-memory</a>
error: only one memory block allowed</td>
</tr>
</tbody>
</table>
<p>https://github.com/WasmEdge/WasmEdge/issues/1122</p>
<p>Most importantly <a href="multi-value.html">multi-value</a> is supported on all platforms</p>
<p>[1] : https://github.com/wasmerio/interface-types see <a href="struct.html">struct</a> [2]
:</p>
<p>threads &amp; tailCall are supported by <a
href="https://wasmedge.org">wasmedge</a>, together with interruptible
aot instruction-count gas and time metering.</p>
<p>âš ï¸ SIMD harmful proposal should be avoided in favour of much cleaner
extension:<br />
<a
href="https://github.com/WebAssembly/flexible-vectors/blob/main/proposals/flexible-vectors/FlexibleVectors.md">Flexible
Vectors</a> great proposal!</p>
<p>Wasmtime supports Memory64, Multiple memories, Module Linking</p>
<p>https://github.com/WebAssembly/module-linking/ see</p>
<p>https://github.com/WebAssembly/component-model
https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md
https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md
https://github.com/WebAssembly/component-model/blob/main/design/mvp/canonical-abi/definitions.py</p>
<p><a
href="https://github.com/WebAssembly/annotations/blob/main/proposals/annotations/Overview.md">https://github.com/WebAssembly/annotations</a>
WasmEdge OK supported by wat2wasm but not wasm-as</p>
<pre><code>(module (@name &quot;GÃ¼mÃ¼sÃ¼&quot;)
  (func $lambda (@name &quot;Î»&quot;) (@js ignore) )
)</code></pre>
<p>https://github.com/WebAssembly/relaxed-simd/issues/ CANCER proposal,
please stop it and add abstract vector ops
<code>i32.vector_add(a,b,out,length)</code></p>
<p>assemblyscript : https://www.assemblyscript.org/status.html</p>
<p>Most importantly <a href="multi-value.html">multi-value</a> is supported on all platforms</p>
<p>Apple is intentionally limiting the mobile web to force your hand to
create an app.</p>
<h1 id="wasix-and-witx">wasix and witx</h1>
<p>To try out cutting edge or extended functionality try this:
https://docs.rs/wasix/latest/wasix/index.html</p>
<h1 id="annotations">annotations</h1>
<p><a
href="https://github.com/WebAssembly/annotations/blob/main/proposals/annotations/Overview.md">https://github.com/WebAssembly/annotations</a></p>
<p>(module (<span class="citation" data-cites="name">@name</span>
â€œGÃ¼mÃ¼sÃ¼â€) (<span class="citation" data-cites="custom">@custom</span>
â€œmy-fancy-sectionâ€ (after func) â€œcontents-bytesâ€) (func $lambda (<span
class="citation" data-cites="name">@name</span> â€œÎ»â€) (param $x (<span
class="citation" data-cites="name">@name</span> â€œÎ±â€) i32) (result i32)
(get_local $x)) )</p>
<h1 id="shared-memory">shared memory</h1>
<p>Shared memory works in many environments even with â€˜threadsâ€™ proposal
not fully implemented.</p>
<pre><code>(import &quot;env&quot; &quot;memory&quot; (memory (;0;) 1 1 shared))
â€¦
const memory = new WebAssembly.Memory({ initial: 1, maximum: 1, shared:true });</code></pre>
<h1 id="atomics">atomics</h1>
<p>https://webassembly.github.io/threads/core/syntax/instructions.html#atomic-memory-instructions</p>
<h1 id="struct-and-array">struct and array</h1>
<p>The <a href="https://github.com/WebAssembly/gc">GC proposal</a> has
types like struct and array, which are a subset of interface types.</p>
<p><a href="https://github.com/WebAssembly/interface-types">interface
types</a> are different from <a
href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md">reference
types</a></p>
<h1 id="interface-types">Interface Types</h1>
<h2 id="motivations">motivations</h2>
<p>With the newly-added externref, WebAssembly can import JavaScript
functions that create JavaScript values that can be passed to the Web
IDL functions via the ECMAScript Binding, but the performance of this
approach may be even worse than the JIT-optimized glue code.</p>
<pre><code>(type $Coord (record (field &quot;x&quot; s32) (field &quot;y&quot; s32)))</code></pre>
<pre><code>intertype ::= u8 | s8 | s16 | u16 | s32 | u32 | s64 | u64 | f32 | f64
            |  char
            |  (list &lt;intertype&gt;)
            |  (record (field &lt;name&gt; &lt;id&gt;? &lt;intertype&gt;)*)
            |  (variant (case &lt;name&gt; &lt;id&gt;? &lt;intertype&gt;?)*)</code></pre>
<p>While core wasmâ€™s type contains reference values which refer to
mutable state, intertype compound values are transitively immutable.</p>
<p>https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md</p>
<pre><code>the following abbreviations only exist in the concrete formats:
bool â‰¡ (variant (case &quot;false&quot;) (case &quot;true&quot;))
string â‰¡ (list char)
( tuple &lt;intertype&gt;*) â‰¡ (record (&quot;ğ’Š&quot; &lt;intertype&gt;)*) for ğ’Š=0,1,...
(flags &lt;name&gt;*) â‰¡ (record (field &lt;name&gt; bool)*)
( enum &lt;name&gt;*) â‰¡ (variant (case &lt;name&gt;)*)
( option &lt;intertype&gt;) â‰¡ (variant (case &quot;none&quot;) (case &quot;some&quot; &lt;intertype&gt;))
( union &lt;intertype&gt;*) â‰¡ (variant (case &quot;ğ’Š&quot; &lt;intertype&gt;)*) for ğ’Š=0,1,...
(expected &lt;intertype&gt;? (error &lt;intertype&gt;)?) â‰¡ (variant (case &quot;ok&quot; &lt;intertype&gt;?) (case &quot;error&quot; &lt;intertype&gt;?))</code></pre>
<h1 id="wit-file-format">.wit file format</h1>
<p>The intention of the <a
href="https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md">wit
format</a> is that it maps down to interface types, so the goal of name
resolution is to effectively create the type section of a wasm module
using interface types. Definitions of named types such as record foo { â€¦
} are intended to map roughly to declarations in the type section of new
types.</p>
<pre><code>record person {
  name: string,
  age: u32,
}
hello: function(who: person) -&gt; string</code></pre>
<h1 id="interface-type-adapter-module-with-adapter-functions">interface
type adapter module with adapter functions</h1>
<pre><code>(adapter_module
  (module $CORE
    ;; â€¦
  )
  (instance $core (instantiate $CORE))
  (import &quot;duplicate&quot; (adapter_func $dup (param string) (result string string)))
  (import &quot;print&quot; (adapter_func $print (param string)))
  (adapter_func (export &quot;print_twice&quot;) (param string)
    call_adapter $dup
    call_adapter $print
    call_adapter $print
  )
  (adapter_func $return_one_of (param string string i32) (result string)
    i32.eqz
    (if (param string string) (result string)
        ( then return)
        ( else drop return))
  )
)</code></pre>
<h1 id="adapter-instructions">adapter instructions</h1>
<pre><code>rotate $n : [ Tn+1 ... T0 ] -&gt; [ Tn ... T0 Tn+1 ]
call_adapter $f : [ P* ] -&gt; [ R* ]
&lt;it&gt;.lift_&lt;ct&gt; : [ ct ] -&gt; [ it ]
&lt;ct&gt;.lower_&lt;it&gt; : [ it ] -&gt; [ ct ]
char.lift : [ i32 ] -&gt; [ char ]
char.lower : [ char ] -&gt; [ i32 ]
list.lift $List $done $liftElem $destructor? : [ T:&lt;type&gt;* ] -&gt; [ $List ]
list.lift_count $List $liftElem $destructor? : [ T*, count:i32 ] -&gt; [ $List ]
list.has_count : [ (list T) ] -&gt; [ (list T), maybe_count:i32, condition:i32 ]
list.is_canon : [ (list E) ] -&gt; [ (list E), maybe_byte_length:i32, condition:i32 ]
list.lift_canon $List &lt;memidx&gt;? $destructor? : [ T*, offset:i32, byte_length:i32 ] -&gt; [ $List ]
list.lower_canon &lt;memidx&gt;? : [ offset:i32, (list E) ] -&gt; []
record.lift $Record $liftFields $destructor? : [ T:&lt;type&gt;* ] -&gt; [ $Record ]
record.lower $Record $lowerFields : [ T:&lt;type&gt;*, $Record ] -&gt; [ U:&lt;type&gt;* ]
variant.lift $Variant $case $liftCase? $destructor? : [ T:&lt;type&gt;* ] -&gt; [ $Variant ]
variant.lower $Variant $lowerCase* : [ T:&lt;type&gt;*, $Variant ] -&gt; [ U:&lt;type&gt;* ]</code></pre>
<pre><code>(module
  (func $foo (param i32 f32))

  (@interface func $adapter_foo (export &quot;foo&quot;) (param s32) (param f32)
    arg.get 0
    s32-to-i32
    arg.get 1
    call-core $foo)
  (@interface func (export &quot;bar&quot;) (param s32) (param f32)
    arg.get 0
    arg.get 1
    call-adapter $adapter_foo)
  (type $tf (func (result funcref)))
  (type $tg (func (result (ref $proc))))
    )</code></pre>
<h1 id="typed-function-references">Typed Function References</h1>
<p>https://github.com/WebAssembly/function-references</p>
<p>Unlike funcref and the existing call_indirect instruction, typed
function references need not be stored into a table to be called (though
they can)</p>
<h2 id="heap-types">Heap types</h2>
<p>part of Typed Function References</p>
<p>https://github.com/WebAssembly/function-references/blob/master/proposals/function-references/Overview.md#types</p>
<p>heaptype ::= <typeidx> | func | extern reftype ::= ref null?
<heaptype></p>
<p>ref.func creates a function reference from a function index call_ref
calls a function through a reference func.bind creates or extends a
closure by binding one or several parameters let â€¦ locally binds
operands to variables</p>
<p>ref.func $f : [] -&gt; [(ref $t)] 0x14 call_ref : [t1* (ref null $t)]
-&gt; [t2*] 0x15 return_call_ref : [t1* (ref null $t)] -&gt; [t2*] 0x16
func.bind $tâ€™ : [t0* (ref null $t)] -&gt; [(ref $tâ€™)] 0x17 let
<blocktype> (local t)* instr* end : [t1* t*] -&gt; [t2*] ref.null ht: []
-&gt; [(ref null ht)] ref.is_null 0xd3 ref.as_non_null : [(ref null ht)]
-&gt; [(ref ht)] 0xd4 br_on_null $l checks for null and branches if
present 0xd6 br_on_non_null $l : [t* (ref null ht)] -&gt; [t*]</p>
<h1 id="type-imports">Type Imports</h1>
<p>https://github.com/WebAssembly/proposal-type-imports/blob/master/proposals/type-imports/Overview.md</p>
<pre><code>(import &quot;...&quot; &quot;...&quot; (type $t))
(export &quot;...&quot; (type &lt;heaptype&gt;))
(type $t (private &lt;type&gt;*))</code></pre>
<p>E.g. a file API might look like</p>
<pre><code>(import &quot;file&quot; &quot;File&quot; (type $File any))
(import &quot;file&quot; &quot;open&quot; (func $open (param $name i32) (result (ref $File))))
(import &quot;file&quot; &quot;read_byte&quot; (func $read (param (ref $File)) (result i32)))</code></pre>
<p>with private implementation</p>
<pre><code>  (type $File (export &quot;File&quot;) (private i32))  ;; file handle</code></pre>
<p>Instructions type <typetype> is an import description with a type
constraint sub <heaptype> describes the type of a type import, with an
upper bound</p>
<p>private <type>* is a new form of type definition private.new
<typeidx> creates a value of private type private.get <typeidx>
<fieldidx> reads a field from a private value</p>
<h3 id="wasm-binary-format">wasm binary format</h3>
<pre><code>deftype is a new category of defined types that generalises the contents of the type section
    eftype ::= &lt;functype&gt; | &lt;privatetype&gt;
    odule ::= {..., types vec(&lt;deftype&gt;)}</code></pre>
<h1 id="module-linking">module-linking</h1>
<p>https://github.com/WebAssembly/module-linking/blob/main/design/proposals/module-linking/Explainer.md</p>
<h1 id="esm-integration">esm-integration</h1>
<p>https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration</p>
<pre><code>import {foo} from &quot;./myModule.wasm&quot;;
&lt;script type=wasm src=&quot;myModule.wasm&quot;&gt; 

`import {foo} from &quot;./myModule.wasm&quot;;`
` (import &quot;./counter.js&quot; &quot;getCount&quot; (func $getCount (func (result i32)))) `
` (import &quot;./counter.wasm&quot; &quot;count&quot; (global i32))`
</code></pre>
<p><a
href="https://awesomeopensource.com/project/MaxGraey/wasm-check">wasm-check</a>
code</p>
<p>wasm-ld â€“shared-memory if compiled with â€˜atomicsâ€™ or
â€˜bulk-memoryâ€™</p>
<h1 id="bulk-memory">bulk-memory</h1>
<pre><code>table.value: copy a region from an element segment

memory.value: copy a region from a data segment
top-2: destination address
top-1: offset into the source segment
top-0: size of memory region in bytes

memory.copy
top-2: destination address
top-1: source address
top-0: size of memory region in bytes

memory.fill
top-2: destination address
top-1: byte value to set
top-0: size of memory region in bytes

table.copy
data.drop: discard the data in an data segment
elem.drop: discard the data in an element segment</code></pre>
<h1 id="memcpy-memory.copy">memcpy =&gt; memory.copy</h1>
<p>replace any exported function called memcpy or memmove with a new
function with the following contents:
<code>(func (param $dst i32) (param $src i32) (param $size i32) (result i32) local.get $dst local.get $src local.get $size memory.copy local.get $dst)</code>
Alternatively connect directly to v8â€™s MemMove function</p>
<h1 id="example-data-to-memory">example data to memory</h1>
<pre><code>(import &quot;a&quot; &quot;global&quot; (global i32))  ;; global 0
(memory 1)
(data (i32.const 0) &quot;hello&quot;)   ;; data segment 0, is active so always copied
(data &quot;goodbye&quot;)               ;; data segment 1, is passive

(func $start
  (if (global.get 0)

    ;; copy data segment 1 into memory 0 (the 0 is implicit)
    (memory.value 1
      (i32.const 16)    ;; target offset
      (i32.const 0)     ;; source offset
      (i32.const 7))    ;; length

    ;; The memory used by this segment is no longer needed, so this segment can
    ;; be dropped.
    (data.drop 1))
)</code></pre>
<h1 id="combining-two-wasm-files">Combining two wasm files</h1>
<p>Combining two wasm files is still absurdly hard, tools regularily get
removed and renamed
https://github.com/bytecodealliance/wit-bindgen/issues/298 Also they
never work on basic standard wasm but need custom sections (wasm-ld) or
non-standard binaries (wasm-tools compose). Wasp tries to fill this gap
by allowing arbitrary arguments: <code>wasp main.wasm lib.wasm</code>
generates out.wasm without preconditions.</p>
<h1 id="administrative-instructions">Administrative Instructions</h1>
<p>https://webassembly.github.io/spec/core/exec/runtime.html#syntax-instr-admin</p>
<pre><code>trap
ref funcaddr
ref.extern funcaddr
invoke funcaddr
label â€¦ end
frame â€¦ end</code></pre>
<h1 id="tool-conventions">Tool conventions</h1>
<p>https://github.com/WebAssembly/tool-conventions</p>
<p>see <a href="debug.html">debug</a></p>
<h1 id="sharedarraybuffer">SharedArrayBuffer</h1>
<p>SharedArrayBuffer has been turned off by default after Spectre:
https://developer.chrome.com/blog/enabling-shared-array-buffer/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer
only available to pages that are cross-origin isolated.
WebAssembly.Memory can still be used to get an instance of
SharedArrayBuffer!</p>
<h1 id="package-registries">package registries</h1>
<p>wasmer is now able to run WAPM packages directly via
<code>wasmer run</code></p>
<h1 id="wast-vs-wat">wast vs wat</h1>
<p>The .wast extension is now used for the scripting language used by
the WebAssembly test suite.</p>
<p>Binaryen wasm-as is ahead with implementing features like reference
types, struct, array, stringref, i8, i16 wabt wat2wasm has better more
forgiving syntax (no brackets needed) but understands no wasm 2.0</p>
<p>wabt wat2wasm â€“version 1.0.32 (mozilla â€¦) binaryen wasm-as â€“version
111</p>
<h1 id="builtins">builtins</h1>
<p>Proposal to offer JS builtins as wasm functions:
https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md</p>
