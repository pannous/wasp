<p><a href="block.html">block</a>, <a href="code.html">code</a> and <a href="closure.html">closure</a> are very similar concepts:<br />
* every <a href="data.html">data</a> with the intention of being <a
href="evaluation">evaluated</a> is a <a href="block.html">block</a> * every <a href="block.html">block</a> with
concrete <a href="binding.html">binding</a> is <a href="code.html">code</a> * every <a href="code.html">code</a> with a local-only
binding is a <a href="closure.html">closure</a></p>
<p>lambdas are closures are blocks with parameters/arguments:</p>
<pre><code>(x,y)=&gt;{x+y}</code></pre>
<p>closures are anonymous functions and <a href="function.html">function</a>s are just names
closures. Todo: is a closure bound to a <a href="variable.html">variable</a> identical to a
function?</p>
<p>The javascript closures notation x =&gt; x*x is beautiful but a bit
hard to type<br />
<code>square = x :: x*x</code> better alternative?</p>
<p>Are the concepts of map and closure unifyable? If so one might simply
write<br />
<code>square = x : x*x</code></p>
<p>Is it possible to write closure as <code>x : x*x</code>? so<br />
<code>{x:x*x}(3) == 9</code> ?<br />
<code>map [1 2 3] {x:x*x}  == [1 4 9]</code> or even<br />
<code>map [1 2 3] x:x*x  == [1 4 9]</code> ?
<code>map [1 2 3] {it*it}</code> <code>map [1 2 3] square</code> # fine
but no closure <a href="todo.html">todo</a></p>
<p>potential alternative syntax for closures:</p>
<pre><code>map [1 2 3] x:x*x
map [1 2 3] x::x*x
map [1 2 3] x=&gt;x*x
map [1 2 3] x-&gt;x*x
map [1 2 3] \x x*x     # lambda nice!
map [1 2 3] |x| x*x    # dangerous pipe
map [1 2 3] [x] x*x    # significant white space
map [1 2 3] «x» x*x    # hard to type, but ok
map [1 2 3] x &gt;&gt; x*x   # c++ gonna hate this, as are bit shifts
map [1 2 3] x :&gt; x*x   # functor fun ;) 
map [1 2 3] (x){x*x}   # conflicts with if, while; (x)=x would require:
map [1 2 3] x{x*x}     # conflicts with setter?
map [1 2 3] {it*it}    # works out of the box, but what about x,y? {it*it2} ??
map [1 2 3] it*it      # no! `it` evaluated in place!
map [1 2 3] {|x| x*x}  # meh ruby 
map [1 2 3] {x in x*x} # swift but in is reserved
map [1 2 3] x into x*x # nice! speakable but as argument (put x into y := ...)
</code></pre>
<p>To understand the difference between <code>map [1 2 3] {it*it}</code>
and <code>map [1 2 3] it*it # no!</code> see un<a href="charged.html">charged</a> <a href="block.html">block</a>
<a href="evaluation.html">evaluation</a></p>
<p># <a href="beauty.html">beauty</a>ful <a href="swift.html">swift</a></p>
<p>The :: syntax is nice because it matches the ‘block’ semantic and is
easy to type Special superfluous symbols 𐬺 𐬻 𐬼 𐬽 𝄈 ⣤⠶⠛⠭⣉⣒</p>
<p>What about two parameter?</p>
<pre><code>\x \y x+y
(x y)-&gt;x+y  
«x y» x+y
|x y| x+y  # unstable white space with pipe
:x :y x+y  # radical! unstable white space
(x y):{x+y} # potential headache
(x,y){x+y} no! conflicts with if, while ...
{$0 + $1}  no! conflicts with outer locals
{#1 + #2}  special locals?</code></pre>
<p>note how the first forms are shorter <em>and</em> cleaner than the
later ones.</p>
<p>Conclusion: (x y)-&gt;x+y works with all kinds of lists (x,y) [x y]
{x;y} and is robust! The operator -&gt; and =&gt; shall be the default
way to denote lambdas backslash and <a href="pipe.html">pipe</a> may be additional syntactic
sugar. <code>into</code> and <code>::</code> <code>:&gt;</code> could
easily be added as synonym for -&gt; but might be saved for other user
cases. solvable? <code>::</code> <code>:&gt;</code> too many different
variants are discouraged! arrows and into are ok though! «x y» x+y
remains hard to type, otherwise nice addition. planned for template
<a href="string.html">string</a>s though?</p>
<p><a href="Rust.html">Rust</a> and <a href="ruby.html">ruby</a> style:</p>
<pre><code>let sum = [1, 4, 2, 3].iter().cloned()
    .filter(|x| x % 2 == 0)
    .fold(0, |sum, i| sum + i);</code></pre>
<p>has it’s own charm because it is easier to type than =&gt; and |x| is
reminiscent of (x) as parameter.</p>
<p>Difference between assigned lambdas and functions?
<code>f=(x)=&gt;x*x</code> lambdas are only visible in the current
context <code>f(x)=x*x</code> functions are visible in the current
class, file or everywhere But for inner functions ( function
declarations within other functions) these concepts could be unified
(?)</p>
<h1 id="closures-in-wasm-with-gc">closures in wasm with GC:</h1>
<p>https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md
<code>(type $code-f64-f64 (func (param $env (ref $clos-f64-f64)) (param $y f64) (result f64)))</code>
…</p>
