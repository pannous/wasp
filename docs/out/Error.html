<p>Errors and exceptions in angle are tightly linked with the concept of
optionally in variables:</p>
<p>The function <code>parse string as int?</code> either returns an int
or a typed error “missing int” <code>!int</code> with associated (?todo)
type format error or number to large etc</p>
<p>The result can be handled positively:<br />
<code>if result { print "we have a number %d" % result }</code><br />
<code>if no result { print "parse did not return a number" }</code><br />
<code>if result failed { print "we have an error %e" % result }</code>
or<br />
<code>if result failed { print "we have an error %s" % result.error }</code><br />
<code>on error { print "we have an error %e" % error }</code></p>
<p>Just like in swift <a href="optional.html">optional</a>s can be unwrapped with tailing
<code>!</code> which throws if the variables value is missing or
erroneous.</p>
<h3 id="errors-vs-exceptions-signals">Errors vs exceptions /
signals</h3>
<p>Errors are non throwing value types, exceptions are … special: they
will propagate through the call stack unless they are explicitly caught,
unlike in Java and similar languages, the try keyword is not necessary
to catch errors, and a catch statement outside a block will catch all
exceptions for its declared method:</p>
<pre><code>fun do_dirty_stuff(){
 eat ()
 drink ()
 catch (no food){}
 catch (drunkenness){}
 on error{}
}</code></pre>
<p>Exceptions can be converted (back) into errors with the
<code>try</code> keyword: <code>int? i=try parse (string)</code> needs
no further catch block</p>
<p>Exceptions are special <a href="signal.html">signal</a>s Because errors have their own
value mechanism, using signals for control flow is encouraged:</p>
<pre><code>fun check the surroundings {
  if man nearby: 
    raise stop the machine!
}

fun main {
 go check the surroundings // asynchronous
 on stop the machine{
  cancel everything
  panic
  exit
}
}</code></pre>
<h3 id="when-do-functions-throw-when-do-they-return-optionals">When do
functions throw, when do they return optionals?</h3>
<p>To avoid function coloring, we may introduce the following
convention: <code>int i= parse (string)</code> is legal but marks the
containing function as potentially throwing
<code>int? i= fun (string)</code> catches any potential integer errors,
but not exceptions<br />
functions explicitly marked as throwing need not return optional values:
<code>parse string as int may fail</code> is identical to
<code>parse string as int?</code> Only when there are multiple return
values will these notations differ.</p>
<p>Note that <code>no result</code> is <a href="true.html">true</a> both for missing and
erroneous objects, which might be sufficient for most control flow,
otherwise one can distinguish with <code>result == 0</code> ==
<code>result null</code> <code>result missing</code>
<code>result empty</code> and <code>result failed</code></p>
