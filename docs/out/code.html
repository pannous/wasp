<p><a href="block.html">block</a>, <a href="code.html">code</a> and <a href="closure.html">closure</a> are very similar concepts:<br />
* every <a href="data.html">data</a> with the intention of being <a
href="evaluation">evaluated</a> is a <a href="block.html">block</a> * every <a href="block.html">block</a> with
concrete binding is <a href="code.html">code</a> * every <a href="code.html">code</a> with a local-only binding
is a <a href="closure.html">closure</a></p>
<p>Code is Data that is charged.</p>
<p>Charging depends on assignment:<br />
<code>f : now</code> # uncharged data, evaluated only when
<code>f()</code> or <code>f!</code> occurs, or via <a href="full evaluation.html">full evaluation</a>
with !!<br />
<code>f := now</code> # semi charged <a href=":=.html">:=</a> evaluated upon normal
<a href="evaluation.html">evaluation</a> of the parent context<br />
<code>def f:{now()}</code> # charged code, evaluated upon partial
<a href="evaluation.html">evaluation</a> of the parent context<br />
<code>f = now</code> # charged symbol/variable: evaluated to the time
whenever the symbol f occurs<br />
<code>f = now</code> # resolved to current time immediately in the
<a href="REPL.html">REPL</a>, or whenever <code>f!</code> occurs</p>
<p>See <a href="evaluation.html">evaluation</a> for details.</p>
<p>While code can visually appear in different forms, under the hood
these are identical after parsing</p>
<pre><code>square := it * it
square a number := number times number
to square a number {
    return number times number
}
(def square (number x) (times x x)) // lispy notation</code></pre>
<p><a href="Expression.html">Expression</a>s can be grouped as normal <a href="list.html">list</a>s, however curly
braces <code>{}</code> are the preferred enclosure.</p>
