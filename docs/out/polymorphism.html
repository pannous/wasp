<p>The ability to write code that can operate on different types is
called polymorphism.</p>
<p>In dynamic languages you often find beasts such as:</p>
<pre><code>function foo(x)
    if x is IntegerType
        x + x
    elif x is Float
        x / 2.0
    elif x is String
        length(x)
    else
        1
    end
end</code></pre>
<p>This is clearly unidiomatic and should be written as</p>
<pre><code>bar of int = it + it
bar of float = it / 2.0
bar of string = its length
bar of any = 1 </code></pre>
<p>This kind of overloading / polymorphism is called [[multiple
dispatch]] if more arguments are involved. Unlike in object orientated
languages multiple dispatch functions can “belong” to multiple
objects.</p>
<p>For example a generic function
<code>slice fruit with tool {...}</code> would live outside the fruit
and tool classes and be applicable to both.</p>
<p>One big disadvantage of the functional approach, besides
discoverability, is lack of encapsulation and private access. This can
be alleviated with modules (in case of Julia)</p>
<h3 id="return-type-polymorphism">return type polymorphism</h3>
<p>Thanks to return polymorphism, the concepts of arguments, functions
and their return type become unified in a general <a href="matching.html">matching</a>
framework:</p>
<pre><code>to render text as pdf:
 return createPdf(text)

to render text as docx:
 return createDocx(text)

render &quot;hello&quot; as pdf
type of result == pdf

docx example = render &quot;hello MS&quot;

render &quot;now what&quot;   # error or interactive compiler question: 
# 1. render text as docx or 
# 2. render text as pdf</code></pre>
<p>Again using <a href="inventions">types as parameter names</a>. PS:
the <a href="return.html">return</a> statement here is superfluous and just for clarification
purposes.</p>
