<p>An <a
href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>
Application binary interface is the low level convention with which
machine code interacts with each other.</p>
<p>Since WASM is pretty primitive and language agnostic, there is a
unique opportunity to define a new ABI! One which at least contains a
minimal concept of classes.</p>
<p>That is: the data representation of types and the calling convention
how these <a href="types.html">types</a> are passed.</p>
<p>designing and ABI is no simple feat. if only all the smart hats that
design the wonderful swift could get together and create a slightly
different new ABI from all the mistakes &amp; things that they’ve
learned:<br />
https://gankra.github.io/blah/swift-abi/</p>
<h1 id="angle-abi">Angle abi</h1>
<p>⚠️ preliminary, subject to changing!</p>
<p>Angle <a href="data.html">data</a> in the wasm linear memory (and in host memory) is
stored in a canonical univeral format:</p>
<pre><code>struct Any_Header {
    Type header;// type / kind OF the object / container, e.g. Array, String, <a href="Node.html">Node</a>
    Type type;  // type WITHIN the container, e.g. generics or Node{.type=
    int length; // count of elements WITHIN the container, not sizeof()
    void *data; // ⚠️ continuation in memory OR pointer to data!
    // void *extra_fields… in objects without data continuation
};</code></pre>
<p>The internal abi makes use of the memory layout of wasp
<a href="node.html">node</a>s.</p>
<h1 id="calling-convention">Calling convention</h1>
<p>All non-primitive functions which take or return the univeral
<a href="type.html">type</a> <a href="node.html">node</a>, that is any class, object or data, uses the following
calling convention:</p>
<p>When multi-value is available, everything gets passed as a pair of (
<a href="Value.html">Value</a>, <a href="Type.html">Type</a> ) When multi-value is not available, everything gets
passed as a <a href="smart-pointer.html">smart-pointer</a>. See source code for details.</p>
<h1 id="canonical-abi">Canonical ABI</h1>
<p>The Wasm consortium grasped the unique opportunity by defining a <a
href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md">Canonical
ABI</a> <a href="wit.html">wit</a> / wasm world <a
href="https://github.com/WebAssembly/component-model/tree/main/design/mvp">Component
Model</a> MVP</p>
<p>Thanks to <a href="multi-value.html">multi-value</a> being already a defactor standard in
<a href="wasm.html">wasm</a>, the <a href="Angle.html">Angle</a> ABI fully makes use of it:</p>
<p>All functions are <a href="polymorphic.html">polymorphic</a> in parameter and return types: each
value is a pair of TypedValue(int32,i64) In fact the pair (int32 i64) is
always easy to read as in the Angle <a href="ABI.html">ABI</a> int32 is always the type i64
is always the value, now matter what.</p>
<p>Since our ValueType is different from the wasm-internal Valtype
(int32 = 0x7f …), we can still use a sprinkle of magic on them and treat
them as <a href="smart-pointer.html">smart-pointer</a>s. Another rationale for using i32 as pointers
and i64 as numbers/values is that 99.9% percent of functions handle
types other than int32.</p>
<p>The value can still be a pointer (if the type indicates so), but it
shouldn’t be a 64bit smart-pointer as there is simply no need for
them.</p>
<p>Internally, within functions i32 can still be used for counters,
loops etc. So the trick would be to use long whenever the keyword int
appears in angle variables, but use int whenever the variables are not
exposed. Since users expect int only to represent i32 values, there is
no loss in precision if long is cast to int when calling external
imports…</p>
<p>Interesting path: add wasm-unknown-unknown-<a href="angle.html">angle</a> as target for
rust etc</p>
<h1 id="c-interops">C interops</h1>
<p>⚠️ depending on optimization techniques and so on, there is no
generic relyable interface to compiled c functions</p>
<!-- # Memory layout

https://www.assemblyscript.org/runtime.html#memory-layout

Overall, AssemblyScript partitions liner memory as follows:
Region  Start offset    End offset  Description
Static data     0   __data_end  Contents of static strings, arrays, etc.
Managed stack   __data_end  __heap_base     Present only if the incremental runtime is used.
Heap    __heap_base     memory.size() << 16     Remaining space is used for dynamic allocations. Can grow.
 -->
<!-- 
# Header layout

Any kind of managed object in AssemblyScript utilizes a managed header for the runtime to operate on:
Name    Offset  Type    Description
mmInfo  -20     usize   Memory manager info
gcInfo  -16     usize   Garbage collector info
gcInfo2     -12     usize   Garbage collector info
rtId    -8  u32     Unique id of the concrete class
rtSize  -4  u32     Size of the data following the header           
    0       Payload starts here


python already uses 3 different string encodings hidden from the user:
https://rushter.com/blog/python-strings-and-memory/
    1 byte per char (Latin-1 encoding)
    2 bytes per char (UCS-2 encoding)
    4 bytes per char (UCS-4 encoding)
we add "undecoded UTF-8" which may need costly transformations to UTF-32 for some algorithms!

 UTF-8 is a storage efficient encoding, but it has one significant disadvantage. Since each character can vary in length of bytes, there is no way to randomly access an individual character by index without scanning the string. So, to perform a simple operation such as string[5] with UTF-8 Python would need to scan a string until it finds a required character.

 Rust's approach (UTF-8 + iterator of grapheme clusters) is ideal.

Languages like Java and Python which have a fat runtime that they don't include with every program and can afford anything. In addition, Java / C # also has JIT compilation that allow them to speed up the whole thing by eliminating most of extra runtime checks. We cannot afford to complicate the runtime this way.

 -->
<h1 id="wasi">WASI</h1>
<p>https://github.com/WebAssembly/WASI/blob/main/legacy/application-abi.md</p>
<p>A command exports a function named _start, with no arguments and no
return values.</p>
<p>_start is the default export which is called when the user doesn’t
select a specific function to call. Commands may also export additional
functions, (similar to “multi-call” executables), which may be
explicitly selected by the user to run instead.</p>
<p>Except as noted below, commands shall not export any mutable globals,
tables, or linear memories.</p>
<p>Command instances may assume that they will be called from the
environment at most once. Command instances may assume that none of
their exports are accessed outside the duration of that call.</p>
<p>All other modules are reactors. A reactor may export a function named
_initialize, with no arguments and no return values.</p>
