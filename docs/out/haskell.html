<h1 id="haskell">Haskell</h1>
<p>Haskell is a great inspiration to all great programmers</p>
<p>Writing a simple declarative sort algorith in Haskell feels like an
eye opener comming from imperative languages. Suddenly all those for(int
i=0;i&lt;count;i++) loops seem extremely ad-hoc, inelegant and
over-specific.</p>
<p>Fortunately for the world, many concepts of Haskell have become
mainstream in other languages, especially lambdas ( <a href="closure.html">closure</a>s /
blocks) and <a href="optional.html">optional</a> values; Closing the gap between mathematical
perfection and everyday pragmatism.</p>
<p>On the other hand Haskell increasingly fixes those shortcomings or
oddities, which unneccissarily complicated tasks. E.g. since only very
recently you can access fields via dot syntax: <a
href="https://github.com/ghc-proposals/ghc-proposals/pull/282">RecordDotSyntax</a></p>
<h2 id="fundamental-issues">Fundamental issues</h2>
<h3 id="limited-polymorphism">Limited polymorphism</h3>
<p>There are some kinds of polymorphism that Haskell doesn’t support, or
at least not natively, e.g. inclusion polymorphism and subtyping, common
in OO languages, where values of one type can act as values of another
type.</p>
<p>The following example, while beautiful, only works for pairs of
numbers:</p>
<pre><code>newtype Pair a b = Pair (a,b)  deriving (Eq,Show) 
instance (Num a, Num b) =&gt; Num (Pair a b) where
   Pair (a,b) + Pair (c,d) = Pair (a+c,b+d)
   Pair (a,b) * Pair (c,d) = Pair (a*c,b*d)
   Pair (a,b) - Pair (c,d) = Pair (a-c,b-d)
   abs    (Pair (a,b)) = Pair (abs a,    abs b) 
   signum (Pair (a,b)) = Pair (signum a, signum b) 
   fromInteger i = Pair (fromInteger i, fromInteger i)</code></pre>
<h3 id="limited-overloading">Limited overloading</h3>
<p>As a consequence of limited polymorphism, you can only overload
operators in very specific contexts.</p>
<h3 id="imperative-thoughts">Imperative thoughts</h3>
<p>While mathematical functional code can be very concise and elegant at
times, often an imperative list of steps and tasks feels more natural or
beautiful to our brain. The standard mathematical notation runs contra
the intuitive time axis:</p>
<p><code>serve(cook(wash(buy(food))))</code> is absurd versus the
natural order</p>
<pre class="wasp"><code>buy food
wash it
cook it
serve it</code></pre>
