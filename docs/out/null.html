<h1 id="nullable-types-and-typed-null.">Nullable Types and Typed
Null.</h1>
<p>null, nil, ø is a <a href="falsey.html">falsey</a> keyword / constant, which can be avoided
with <a href="optional.html">optional</a> <a href="typing.html">typing</a></p>
<p>Vulgarly, <a href="unknown.html">unknown</a> is a well defined null, whereas <a href="undefined.html">undefined</a>
is an ill defined null.</p>
<h2 id="nullable-types">Nullable Types</h2>
<p>All types can be expressed to be <a href="optional.html">optional</a>, that is their values
are allowed to be <a href="missing.html">missing</a> <a href="empty.html">empty</a> or in old terms: <a href="null.html">null</a>.</p>
<pre><code>class contact {
 name required
 maybe email
 phone optional
}</code></pre>
<p>The optionally is really part of the variables (and parameters), but
for internal propagation all types have an internal flag
<code>nullable</code>.</p>
<p>Since this is an ubiquitously used paradigm, it deserves its own
<a href="sigil.html">sigil</a>:</p>
<pre><code>class contact {
 name 
 email?
 phone?
}</code></pre>
<p>It makes the code more readable and behave like <a href="swift.html">swift</a>, <a href="kotlin.html">kotlin</a>
and <a
href="https://medium.com/dartlang/why-nullable-types-7dd93c28c87a">dart</a>;
avoiding the overly verbose Optional&lt;&gt;, Some&lt;&gt;, Maybe …
syntax of <a href="rust.html">rust</a> and haskell.</p>
<h2 id="typed-null">Typed Null</h2>
<p>It is important that (except in unsafe code) null is a keyword, not
an object.</p>
<p>So <code>Person? may_be_missing = null;</code> is just syntactic
sugar for <code>Person? may_be_missing = Person.null</code>.</p>
<p>In English we say John is a missing person, not John is a
missing.</p>
<p>Instead of the <a href="swift.html">swift</a>y <code>if let x_found=maybe_x {}</code>
syntax, Angle uses <code>if truthy {}</code> control flow analysis:</p>
<pre><code>String? possibly_email=some_func()
if possibly_email {
   print(may_be_missing.size) // surely not missing
}</code></pre>
<p>Conversely to test if an <a href="optional.html">optional</a> value
<code>may_be_missing</code> is empty, check with</p>
<pre><code>if may_be_missing empty {}
if may_be_missing absent {}
if may_be_missing missing {}
if may_be_missing unknown {}
if may_be_missing undefined {}
if not may_be_missing {} </code></pre>
<p>!!! there is never any need to check for combinations of these
keywords: if may_be_missing unknown or may_be_missing undefined {}</p>
<p>Instead, they are either synonymous or strict sub concepts, in any
case one keyword always captures all destitute cases.</p>
<p>The <a href="empty.html">empty</a> keyword really checks missing or empty. Todo: It is
redundant to the <a href="truthiness.html">truthiness</a> check
<code>if not may_be_missing {}</code></p>
<p>In addition to the swift-like optionality operator ‘?’
<code>cat{name:string?}</code> angle has a <a href="required.html">required</a> operator ‘!’
<code>cat{name:string!}</code> which is different to the default
<code>cat{name:string}</code> in the sense that … &lt;<todo>&gt;</p>
<p>null types / typed nulls can be represented via [[smart
pointers]].</p>
