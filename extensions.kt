import kotlin.io.println as println
import kotlin.io.println as puts
import kotlin.collections.mutableListOf as list
import kotlin.collections.mutableMapOf as map

import java.io.File
import java.math.BigDecimal
import java.math.BigInteger
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import kotlin.reflect.KCallable
import kotlin.reflect.KFunction
import kotlin.reflect.full.declaredMemberFunctions
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.declaredMembers
import kotlin.reflect.jvm.reflect

/*
WTFFFFFFFFFF

 time /opt/kotlin/kotlin-native/dist/bin/kotlinc extensions.kt
 user	0m11.476s // ok native but still WHAAAAAAAAATHEFUCK!!!
 NOT CACHING! SAME EVERY RUN!
 */
//sealed class Extensions {


// PROPERTY!
val String.size: Int
	get() {
		return this.length
	}
// lol ^^>> wtf
val Collection<*>.length: Int
	get() {
		return this.size
	}


object Extensions {
	init {
		// make assertions throw!!! also via -ea JVM option
		val loader = ClassLoader.getSystemClassLoader()// javaClass.classLoader
		loader.setDefaultAssertionStatus(true)
	}

	//	fun getResolve_home() = { path: String -> path.replace("~", System.getenv("HOME")) }
	fun getResolve_home(path: String): String {
		return path.replace("~", System.getenv("HOME"))
	}

	fun read(file: String): List<String> {
		var current = System.getProperty("user.dir")
		return File(getResolve_home(file)).readLines()
	}

	fun append(file: String, line: String) {
		if(!exists(file))
			Files.write(Paths.get(getResolve_home(file)), line.toByteArray(), StandardOpenOption.CREATE_NEW)
		else
			Files.write(Paths.get(getResolve_home(file)), line.toByteArray(), StandardOpenOption.APPEND)
	}

	fun temp(file: String, lines: String) {
		Files.write(Paths.get(getResolve_home(file)), lines.toByteArray(), StandardOpenOption.DELETE_ON_CLOSE)
	}

	fun write(file: String, lines: String, delete:Boolean=false) {
		if(delete)Files.deleteIfExists(Paths.get(file))
		Files.write(Paths.get(getResolve_home(file)), lines.toByteArray(), StandardOpenOption.CREATE_NEW)
	}

	fun exists(file: String):Boolean{
		return Files.exists(Paths.get(file))
	}

}
//val list= arrayOf()

operator fun Boolean.plus(element: Boolean): Boolean{
	return this or element
}

operator fun Boolean.times(element: Boolean): Boolean{
	return this and element
}
operator fun Boolean.minus(element: Boolean): Boolean{
	return this xor element
}

// ADD slice operator list[1..10]
operator fun <E> List<E>.get(range: IntRange):Collection<E> {
	return this.subList(range.first, range.last + 1)
}
operator fun <E> List<E>.get(range: Pair<Int,Int>):Collection<E> {
	return this.subList(range.first, range.second + 1)
}

// EXTENSION PROPERTY!!!
val <K, V> Map<K, V>.len: Int
	get() {return this.size}

fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
	return { x -> f(g(x)) }
}
//val oddLength = compose(::isOdd, ::length)

// https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-function/index.html
fun <T> dir(func: KFunction<T>): Pair<String, List<String>> {
	val args = func.parameters.map { ""+it.name }.toList()
	return "args" to args
}

// https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html
//	println(members)
//[boundReceiver, caller, container, defaultCaller, descriptor, isBound, isExternal, isInfix, isInline, isOperator, isSuspend, name, signature, createConstructorCaller, createInstanceMethodCaller, createJvmStaticInObjectCaller, createStaticMethodCaller, equals, getArity, hashCode, toString, annotations, isAbstract, isAnnotationConstructor, isFinal, isOpen, parameters, returnType, typeParameters, visibility, call, callBy, invoke]

//class kotlin.reflect.jvm.internal.KTypeImpl
//class kotlin.reflect.jvm.internal.KClassImpl


/*
java.lang.UnsupportedOperationException: This class is an internal synthetic class generated by the Kotlin compiler, such as an anonymous class for a lambda, a SAM wrapper, a callable reference, etc. It's not a Kotlin class or interface, so the reflection library has no idea what declarations does it have. Please use Java reflection to inspect this class:
 */
fun dir(inspect: Any): List<String> {
	var members=inspect::class.members.map{it.name}.distinct()
	members+=inspect::class.typeParameters.map{it.name}.distinct()
	members+=inspect::class.constructors.map{it.name}.distinct()
	members+=inspect::class.declaredMembers.map{it.name}.distinct()
	members+=inspect::class.declaredMemberFunctions.map{it.name}.distinct()
	members+=inspect::class.declaredMemberProperties.map{it.name}.distinct()
	members=members.distinct()
	println(inspect)
	println(inspect.javaClass)
	print(members)
//	o::class.supertypes.map { it.members.map{it.name}.distinct() }
	return members;
}

//operator fun Number.times

infix fun <T> List<T>.wow(more: List<T>): Set<T> {
	return this.union(more)
}

infix fun <T> Int.of(more: List<T>): T {
	return more[this]
}

// like a in {..} but returns value, not bool
/*
	if("a" in map) puts("a" of map)

 */
infix fun <K,V> Any.of(more: Map<K,V>): V? {
	if(this is KCallable<*>)
		puts("!!!"+this.name)
	if(this is KCallable<*>)
		return this.call(more) as V? // how? egal
	if(this is Function<*>)
		return this.run { more.first}
	return more[this as K]
}

fun <R: Any?> readPropery(instance: Any, propertyName: String): R {
	val clazz = instance.javaClass.kotlin
	@Suppress("UNCHECKED_CAST")
	return clazz.declaredMemberProperties.first { it.name == propertyName }.get(instance) as R
}

private val <K, V> Map<K, V>.first: V?
	get() {
//public inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {
		return this.get(0 as K)
	}

// use [1]+[2]
//infix fun <T> List<T>.and(secList: List<T>): Set<T> {
//	return this.union(secList)
//}
//infix fun <T> List<T>.or(secList: List<T>): Set<T> {
//	return this.union(secList)
//}

fun <T> List<T>.unique(): List<T> {
	return this.distinct()
}
//List::[contains, addAll, clear, ensureCapacityInternal, rangeCheckForAdd, fastRemove, replaceAll, listIterator, batchRemove, removeAll, add, clone, iterator, removeRange, get, forEach, trimToSize, spliterator, toArray, indexOf, lastIndexOf, isEmpty, removeAt, remove, sort, readObject, elementData, rangeCheck, set, ensureExplicitCapacity, grow, removeIf, writeObject, ensureCapacity, retainAll, subList, outOfBoundsMsg, size, parallelStream, stream, hashCode, equals, toString, containsAll, modCount, hugeCapacity, calculateCapacity, subListRangeCheck, serialVersionUID, DEFAULT_CAPACITY, EMPTY_ELEMENTDATA, DEFAULTCAPACITY_EMPTY_ELEMENTDATA, MAX_ARRAY_SIZE]



// PROPERTY!
val Int.square: Number
	get() {
		return this*this
	}


//val Number.double: Number
//	get() {
//		return this*2 // why not?
//	}



val Number.square: Number
	get() {
		return this*this
//		if(this as Any is Boolean)
//			return if(this==true) 1 else  0
//		return this as Number * this as Number
	}

operator fun Map<*,*>.minus(other: Any):Map<*,*>{
	val neu=this.toMutableMap()
	if(other is Map<*,*>)
		for ((x,v) in other)
			neu.remove(x)
	if(other is Iterable<*>)
		for (x in other)
			neu.remove(x)
	neu.remove(other)
	return neu
}

// WHY??
operator fun Number.times(number: Number): Number {
	if(this is Double)return this*number as Double
	if(this is Long)return this*number as Long
	if(this is Short)return this*number as Short
	if(this is Byte)return this*number as Byte
	if(this is Float)return this*number as Float
	if(this is Int)return this*number as Int
//	if(this is Integer)return this*number as Integer
	if(this is BigDecimal)return this.multiply(number as BigDecimal) // why?
	if(this is BigInteger)return this*multiply(number as BigInteger)
//	return (this as BigDecimal).times(number as BigDecimal) // why recursive?
	throw Error ("WHAT?")
//	if(this is Boolean)return this*number
}

//+a 	a.unaryPlus()

/*
// clutters Any root!
operator fun Any?.unaryPlus():Boolean{
	if (this == null) return false
	return when (this) {
		is Collection<*> -> !this.isEmpty()
		is Map<*,*> -> !this.isEmpty()
		is String -> !this.isBlank()
		is Boolean -> this==true
		is Int -> throw Error("MUST NOT BE")//this>0 //!! +7
		is Number -> this!=0
		else -> true
	}
	// if(+obj) puts("ok")
}
*/

operator fun Any?.not(): Boolean {
	// if(!obj) puts("null or empty")
	if (this == null) return true
	return when (this) {
		is Collection<*> -> this.isEmpty()
		is Map<*,*> -> this.isEmpty()
		is String -> this.isBlank()
		is Boolean -> this==false
		is Char -> this==0.toChar()
		is Number -> this==0
		else -> false
	}
//	if(this is Collection<*>) return this.isEmpty()
//	if(this is Map<*,*>) return this.isEmpty()
//	if(this is Number)return this==0
//	if(this is Boolean)return this==false
//	if(this is String)return this.isBlank() // space is nothing!
//	return false
//	throw Error("too hacked"+this+" "+this.javaClass)
}

// WOW but dangerous!
//use a() instead of puts(a)  stupid hack!
//operator fun Any?.invoke(): Boolean {
//	puts("DEBUG: "+this)
//	return true
//}


infix fun <K,V> Map<K,V>.has(key: K): Boolean {
	return key in this
}
/*
useless toys:

infix fun Any.equals(other: Any): Boolean {
	return this==other
}

fun Any?.puts(a: Any) {
	println(a)
} USE THIS:
import kotlin.io.println as println
import kotlin.io.println as puts
*/

/*
	if (this == null) return false
	if(this is Array<*>) return ! this.isEmpty()
	if(this is Number)return this!=0
	throw Error("too hacked")
}
*/

fun size(x: Collection<*>) = x.size
fun length(x: Collection<*>) = x.size
fun length(x: MutableMap<*,*>) = x.size
fun length(x: String) = x.length
fun size(x: String) = x.length
